;buildInfoPackage: chisel3, version: 3.1.8, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-07-08 17:44:42.884, builtAtMillis: 1562607882884
circuit Test : 
  module DataGen : 
    input clock : Clock
    input reset : UInt<1>
    output io : {a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    io.a.isZero <= UInt<1>("h00") @[Test.scala 15:16]
    io.a.isInf <= UInt<1>("h00") @[Test.scala 16:16]
    io.a.sign <= UInt<1>("h00") @[Test.scala 17:16]
    io.b.sign <= UInt<1>("h00") @[Test.scala 19:14]
    io.b.isInf <= UInt<1>("h00") @[Test.scala 20:16]
    io.b.isZero <= UInt<1>("h00") @[Test.scala 21:16]
    io.a.exponent <= UInt<5>("h0e") @[Test.scala 23:17]
    io.a.fraction <= UInt<4>("h04") @[Test.scala 24:17]
    io.b.exponent <= UInt<5>("h0f") @[Test.scala 26:17]
    io.b.fraction <= UInt<4>("h00") @[Test.scala 27:17]
    
  module ZeroPadRight : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<10>, out : UInt<3>}
    
    node _T_9 = bits(io.in, 9, 6) @[PositDef.scala 139:20]
    io.out <= _T_9 @[PositDef.scala 139:12]
    
  module ShiftRightSticky : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<10>, flip shift : UInt<4>, out : UInt<3>, sticky : UInt<1>, stickyAnd : UInt<1>}
    
    wire valVector : UInt<3>[3] @[PositDef.scala 168:23]
    wire valVectorOfVecs : UInt<1>[3][3] @[PositDef.scala 169:29]
    node _T_109 = cat(valVectorOfVecs[2][2], valVectorOfVecs[2][1]) @[PositDef.scala 171:40]
    node _T_110 = cat(_T_109, valVectorOfVecs[2][0]) @[PositDef.scala 171:40]
    valVector[2] <= _T_110 @[PositDef.scala 171:18]
    node _T_111 = cat(valVectorOfVecs[1][2], valVectorOfVecs[1][1]) @[PositDef.scala 171:40]
    node _T_112 = cat(_T_111, valVectorOfVecs[1][0]) @[PositDef.scala 171:40]
    valVector[1] <= _T_112 @[PositDef.scala 171:18]
    node _T_113 = cat(valVectorOfVecs[0][2], valVectorOfVecs[0][1]) @[PositDef.scala 171:40]
    node _T_114 = cat(_T_113, valVectorOfVecs[0][0]) @[PositDef.scala 171:40]
    valVector[0] <= _T_114 @[PositDef.scala 171:18]
    wire valSticky : UInt<3> @[PositDef.scala 175:23]
    wire valStickyVec : UInt<1>[3] @[PositDef.scala 176:26]
    node _T_124 = cat(valStickyVec[2], valStickyVec[1]) @[PositDef.scala 177:29]
    node _T_125 = cat(_T_124, valStickyVec[0]) @[PositDef.scala 177:29]
    valSticky <= _T_125 @[PositDef.scala 177:13]
    wire valStickyAnd : UInt<3> @[PositDef.scala 179:26]
    wire valStickyAndVec : UInt<1>[3] @[PositDef.scala 180:29]
    node _T_135 = cat(valStickyAndVec[2], valStickyAndVec[1]) @[PositDef.scala 181:35]
    node _T_136 = cat(_T_135, valStickyAndVec[0]) @[PositDef.scala 181:35]
    valStickyAnd <= _T_136 @[PositDef.scala 181:16]
    wire maxShift : UInt<1> @[PositDef.scala 183:22]
    inst padding of ZeroPadRight @[PositDef.scala 185:23]
    padding.clock <= clock
    padding.reset <= reset
    padding.io.in <= io.in @[PositDef.scala 186:17]
    node _T_138 = bits(padding.io.out, 0, 0) @[PositDef.scala 189:44]
    valVectorOfVecs[0][0] <= _T_138 @[PositDef.scala 189:27]
    node _T_139 = bits(padding.io.out, 1, 1) @[PositDef.scala 189:44]
    valVectorOfVecs[0][1] <= _T_139 @[PositDef.scala 189:27]
    node _T_140 = bits(padding.io.out, 2, 2) @[PositDef.scala 189:44]
    valVectorOfVecs[0][2] <= _T_140 @[PositDef.scala 189:27]
    node _T_141 = bits(io.in, 6, 0) @[PositDef.scala 196:29]
    node _T_143 = neq(_T_141, UInt<1>("h00")) @[PositDef.scala 196:59]
    valStickyVec[0] <= _T_143 @[PositDef.scala 196:21]
    node _T_144 = bits(io.in, 6, 0) @[PositDef.scala 197:32]
    node _T_145 = not(_T_144) @[PositDef.scala 197:62]
    node _T_147 = eq(_T_145, UInt<1>("h00")) @[PositDef.scala 197:62]
    valStickyAndVec[0] <= _T_147 @[PositDef.scala 197:24]
    node _T_148 = bits(io.shift, 0, 0) @[PositDef.scala 209:20]
    node _T_150 = bits(valVector[0], 0, 0) @[PositDef.scala 212:52]
    valVectorOfVecs[1][0] <= _T_150 @[PositDef.scala 212:33]
    node _T_151 = bits(io.shift, 0, 0) @[PositDef.scala 209:20]
    node _T_153 = bits(valVector[0], 1, 1) @[PositDef.scala 212:52]
    valVectorOfVecs[1][1] <= _T_153 @[PositDef.scala 212:33]
    node _T_154 = bits(io.shift, 0, 0) @[PositDef.scala 203:20]
    node _T_156 = bits(valVector[0], 2, 2) @[PositDef.scala 206:52]
    valVectorOfVecs[1][2] <= _T_156 @[PositDef.scala 206:33]
    wire _T_158 : UInt<1> @[PositDef.scala 216:28]
    wire _T_160 : UInt<1> @[PositDef.scala 217:31]
    node _T_161 = bits(io.shift, 0, 0) @[PositDef.scala 218:16]
    _T_158 <= UInt<1>("h00") @[PositDef.scala 223:20]
    _T_160 <= UInt<1>("h01") @[PositDef.scala 224:23]
    node _T_165 = or(valStickyVec[0], _T_158) @[PositDef.scala 226:44]
    valStickyVec[1] <= _T_165 @[PositDef.scala 226:21]
    node _T_166 = and(valStickyAndVec[0], _T_160) @[PositDef.scala 227:48]
    valStickyAndVec[1] <= _T_166 @[PositDef.scala 227:24]
    node _T_167 = bits(io.shift, 1, 1) @[PositDef.scala 209:20]
    node _T_169 = bits(valVector[1], 0, 0) @[PositDef.scala 212:52]
    valVectorOfVecs[2][0] <= _T_169 @[PositDef.scala 212:33]
    node _T_170 = bits(io.shift, 1, 1) @[PositDef.scala 203:20]
    node _T_172 = bits(valVector[1], 1, 1) @[PositDef.scala 206:52]
    valVectorOfVecs[2][1] <= _T_172 @[PositDef.scala 206:33]
    node _T_173 = bits(io.shift, 1, 1) @[PositDef.scala 203:20]
    node _T_175 = bits(valVector[1], 2, 2) @[PositDef.scala 206:52]
    valVectorOfVecs[2][2] <= _T_175 @[PositDef.scala 206:33]
    wire _T_177 : UInt<1> @[PositDef.scala 216:28]
    wire _T_179 : UInt<1> @[PositDef.scala 217:31]
    node _T_180 = bits(io.shift, 1, 1) @[PositDef.scala 218:16]
    _T_177 <= UInt<1>("h00") @[PositDef.scala 223:20]
    _T_179 <= UInt<1>("h01") @[PositDef.scala 224:23]
    node _T_184 = or(valStickyVec[1], _T_177) @[PositDef.scala 226:44]
    valStickyVec[2] <= _T_184 @[PositDef.scala 226:21]
    node _T_185 = and(valStickyAndVec[1], _T_179) @[PositDef.scala 227:48]
    valStickyAndVec[2] <= _T_185 @[PositDef.scala 227:24]
    node _T_187 = geq(io.shift, UInt<2>("h03")) @[PositDef.scala 251:27]
    maxShift <= _T_187 @[PositDef.scala 251:14]
    io.out <= valVector[2] @[PositDef.scala 257:14]
    node _T_189 = bits(valSticky, 2, 2) @[PositDef.scala 258:29]
    io.sticky <= _T_189 @[PositDef.scala 258:17]
    node _T_190 = bits(valStickyAnd, 2, 2) @[PositDef.scala 259:35]
    io.stickyAnd <= _T_190 @[PositDef.scala 259:20]
    
  module ZeroPadRight_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<4>, out : UInt<2>}
    
    node _T_9 = bits(io.in, 3, 1) @[PositDef.scala 139:20]
    io.out <= _T_9 @[PositDef.scala 139:12]
    
  module PositMultiply : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, flip b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, trailingBits : UInt<2>, stickyBit : UInt<1>}
    
    wire abSign : UInt<1> @[PositMultiply.scala 31:20]
    wire abExp : UInt<6> @[PositMultiply.scala 32:19]
    wire abExpTooSmall : UInt<1> @[PositMultiply.scala 33:27]
    wire abExpTooLarge : UInt<1> @[PositMultiply.scala 34:27]
    wire abExpShift : UInt<1> @[PositMultiply.scala 35:24]
    wire finalExpExtended : UInt<6> @[PositMultiply.scala 37:30]
    wire finalExp : UInt<5> @[PositMultiply.scala 38:22]
    wire abUnshiftedProduct : UInt<10> @[PositMultiply.scala 39:32]
    wire abShiftedProduct : UInt<10> @[PositMultiply.scala 40:30]
    wire underflowShift : UInt<4> @[PositMultiply.scala 41:28]
    wire underflowProduct : UInt<3> @[PositMultiply.scala 42:30]
    wire underflowSticky : UInt<1> @[PositMultiply.scala 44:29]
    wire normalTrailingBits : UInt<2> @[PositMultiply.scala 45:32]
    wire normalStickyBit : UInt<1> @[PositMultiply.scala 46:29]
    inst shiftRightWithSticky of ShiftRightSticky @[PositMultiply.scala 49:36]
    shiftRightWithSticky.clock <= clock
    shiftRightWithSticky.reset <= reset
    shiftRightWithSticky.io.in <= abShiftedProduct @[PositMultiply.scala 52:30]
    shiftRightWithSticky.io.shift <= underflowShift @[PositMultiply.scala 53:33]
    underflowProduct <= shiftRightWithSticky.io.out @[PositMultiply.scala 54:19]
    underflowSticky <= shiftRightWithSticky.io.sticky @[PositMultiply.scala 55:19]
    wire unusedStickyAnd : UInt<1> @[PositMultiply.scala 57:29]
    unusedStickyAnd <= shiftRightWithSticky.io.stickyAnd @[PositMultiply.scala 58:19]
    inst zeroPadRight of ZeroPadRight_1 @[PositMultiply.scala 64:28]
    zeroPadRight.clock <= clock
    zeroPadRight.reset <= reset
    node _T_30 = bits(abShiftedProduct, 3, 0) @[PositMultiply.scala 66:41]
    zeroPadRight.io.in <= _T_30 @[PositMultiply.scala 66:22]
    normalTrailingBits <= zeroPadRight.io.out @[PositMultiply.scala 67:24]
    node _T_31 = xor(io.a.sign, io.b.sign) @[PositMultiply.scala 70:23]
    abSign <= _T_31 @[PositMultiply.scala 70:10]
    node _T_33 = cat(UInt<1>("h01"), io.a.fraction) @[Cat.scala 30:58]
    node _T_35 = cat(UInt<1>("h01"), io.b.fraction) @[Cat.scala 30:58]
    node _T_36 = mul(_T_33, _T_35) @[PositMultiply.scala 74:54]
    abUnshiftedProduct <= _T_36 @[PositMultiply.scala 74:22]
    node _T_37 = bits(abUnshiftedProduct, 9, 9) @[PositMultiply.scala 78:35]
    abExpShift <= _T_37 @[PositMultiply.scala 78:14]
    node _T_38 = add(io.a.exponent, io.b.exponent) @[PositMultiply.scala 83:26]
    node _T_39 = tail(_T_38, 1) @[PositMultiply.scala 83:26]
    node _T_40 = add(_T_39, abExpShift) @[PositMultiply.scala 83:42]
    node _T_41 = tail(_T_40, 1) @[PositMultiply.scala 83:42]
    abExp <= _T_41 @[PositMultiply.scala 83:9]
    node _T_42 = bits(abExpShift, 0, 0) @[PositMultiply.scala 88:26]
    when _T_42 : @[PositMultiply.scala 88:30]
      abShiftedProduct <= abUnshiftedProduct @[PositMultiply.scala 89:22]
      skip @[PositMultiply.scala 88:30]
    else : @[PositMultiply.scala 90:16]
      node _T_43 = bits(abUnshiftedProduct, 8, 0) @[PositMultiply.scala 91:47]
      node _T_45 = cat(_T_43, UInt<1>("h00")) @[Cat.scala 30:58]
      abShiftedProduct <= _T_45 @[PositMultiply.scala 91:22]
      skip @[PositMultiply.scala 90:16]
    node _T_47 = lt(abExp, UInt<4>("h0c")) @[PositMultiply.scala 96:27]
    abExpTooSmall <= _T_47 @[PositMultiply.scala 96:17]
    node _T_49 = gt(abExp, UInt<6>("h024")) @[PositMultiply.scala 99:27]
    abExpTooLarge <= _T_49 @[PositMultiply.scala 99:17]
    node _T_51 = sub(abExp, UInt<4>("h0c")) @[PositMultiply.scala 101:29]
    node _T_52 = asUInt(_T_51) @[PositMultiply.scala 101:29]
    node _T_53 = tail(_T_52, 1) @[PositMultiply.scala 101:29]
    finalExpExtended <= _T_53 @[PositMultiply.scala 101:20]
    node _T_54 = bits(finalExpExtended, 4, 0) @[PositMultiply.scala 103:31]
    finalExp <= _T_54 @[PositMultiply.scala 103:12]
    node _T_56 = bits(abExp, 3, 0) @[PositMultiply.scala 108:50]
    node _T_57 = sub(UInt<4>("h0c"), _T_56) @[PositMultiply.scala 108:43]
    node _T_58 = asUInt(_T_57) @[PositMultiply.scala 108:43]
    node _T_59 = tail(_T_58, 1) @[PositMultiply.scala 108:43]
    underflowShift <= _T_59 @[PositMultiply.scala 108:18]
    node _T_60 = or(io.a.isInf, io.b.isInf) @[PositMultiply.scala 110:30]
    io.out.isInf <= _T_60 @[PositMultiply.scala 110:16]
    node _T_62 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 112:21]
    node _T_63 = or(io.a.isZero, io.b.isZero) @[PositMultiply.scala 112:52]
    node _T_64 = and(_T_62, _T_63) @[PositMultiply.scala 112:36]
    io.out.isZero <= _T_64 @[PositMultiply.scala 112:17]
    node _T_66 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 114:19]
    node _T_67 = bits(abSign, 0, 0) @[PositMultiply.scala 114:50]
    node _T_68 = and(_T_66, _T_67) @[PositMultiply.scala 114:34]
    io.out.sign <= _T_68 @[PositMultiply.scala 114:15]
    node _T_69 = or(io.out.isZero, io.out.isInf) @[PositMultiply.scala 116:22]
    when _T_69 : @[PositMultiply.scala 116:39]
      io.out.exponent <= UInt<1>("h00") @[PositMultiply.scala 117:21]
      skip @[PositMultiply.scala 116:39]
    else : @[PositMultiply.scala 118:39]
      node _T_71 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 118:35]
      when _T_71 : @[PositMultiply.scala 118:39]
        io.out.exponent <= UInt<5>("h018") @[PositMultiply.scala 119:21]
        skip @[PositMultiply.scala 118:39]
      else : @[PositMultiply.scala 120:16]
        io.out.exponent <= finalExp @[PositMultiply.scala 121:21]
        skip @[PositMultiply.scala 120:16]
    node _T_73 = or(io.out.isInf, io.out.isZero) @[PositMultiply.scala 124:21]
    node _T_74 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 124:61]
    node _T_75 = or(_T_73, _T_74) @[PositMultiply.scala 124:38]
    when _T_75 : @[PositMultiply.scala 124:65]
      io.out.fraction <= UInt<1>("h00") @[PositMultiply.scala 125:21]
      skip @[PositMultiply.scala 124:65]
    else : @[PositMultiply.scala 126:16]
      node _T_77 = bits(abShiftedProduct, 8, 5) @[PositMultiply.scala 127:40]
      io.out.fraction <= _T_77 @[PositMultiply.scala 127:21]
      skip @[PositMultiply.scala 126:16]
    node _T_78 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 130:21]
    node _T_79 = or(_T_78, io.b.isZero) @[PositMultiply.scala 130:36]
    node _T_80 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 130:74]
    node _T_81 = or(_T_79, _T_80) @[PositMultiply.scala 130:51]
    when _T_81 : @[PositMultiply.scala 130:78]
      io.trailingBits <= UInt<1>("h00") @[PositMultiply.scala 131:21]
      skip @[PositMultiply.scala 130:78]
    else : @[PositMultiply.scala 132:39]
      node _T_83 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 132:35]
      when _T_83 : @[PositMultiply.scala 132:39]
        node _T_84 = bits(underflowProduct, 1, 0) @[PositMultiply.scala 133:40]
        io.trailingBits <= _T_84 @[PositMultiply.scala 133:21]
        skip @[PositMultiply.scala 132:39]
      else : @[PositMultiply.scala 134:16]
        io.trailingBits <= normalTrailingBits @[PositMultiply.scala 135:21]
        skip @[PositMultiply.scala 134:16]
    node _T_85 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 138:21]
    node _T_86 = or(_T_85, io.b.isZero) @[PositMultiply.scala 138:36]
    node _T_87 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 138:74]
    node _T_88 = or(_T_86, _T_87) @[PositMultiply.scala 138:51]
    when _T_88 : @[PositMultiply.scala 138:78]
      io.stickyBit <= UInt<1>("h00") @[PositMultiply.scala 139:18]
      skip @[PositMultiply.scala 138:78]
    else : @[PositMultiply.scala 140:39]
      node _T_90 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 140:35]
      when _T_90 : @[PositMultiply.scala 140:39]
        io.stickyBit <= underflowSticky @[PositMultiply.scala 141:18]
        skip @[PositMultiply.scala 140:39]
      else : @[PositMultiply.scala 142:16]
        io.stickyBit <= normalStickyBit @[PositMultiply.scala 143:18]
        skip @[PositMultiply.scala 142:16]
    node _T_91 = bits(abShiftedProduct, 1, 0) @[PositMultiply.scala 147:40]
    node _T_93 = neq(_T_91, UInt<1>("h00")) @[PositMultiply.scala 147:101]
    normalStickyBit <= _T_93 @[PositMultiply.scala 147:21]
    
  module PositEncode : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {bits : UInt<8>}}
    
    wire signedRegime : SInt<4> @[PositEncode.scala 22:26]
    wire shiftBits : UInt<3> @[PositEncode.scala 24:23]
    wire posRegime : UInt<1> @[PositEncode.scala 26:23]
    wire esAndFraction : SInt<7> @[PositEncode.scala 28:27]
    wire esAndFractionShifted : SInt<7> @[PositEncode.scala 30:34]
    node _T_14 = dshr(esAndFraction, shiftBits) @[PositEncode.scala 37:41]
    esAndFractionShifted <= _T_14 @[PositEncode.scala 37:24]
    wire firstBits : UInt<2> @[PositEncode.scala 39:23]
    node _T_17 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 40:18]
    when _T_17 : @[PositEncode.scala 40:27]
      firstBits <= UInt<2>("h02") @[PositEncode.scala 41:15]
      skip @[PositEncode.scala 40:27]
    else : @[PositEncode.scala 42:16]
      firstBits <= UInt<1>("h01") @[PositEncode.scala 43:15]
      skip @[PositEncode.scala 42:16]
    node _T_20 = bits(io.in.exponent, 0, 0) @[PositEncode.scala 47:55]
    node _T_21 = cat(_T_20, io.in.fraction) @[Cat.scala 30:58]
    node _T_22 = cat(firstBits, _T_21) @[Cat.scala 30:58]
    node _T_23 = asSInt(_T_22) @[PositEncode.scala 47:83]
    esAndFraction <= _T_23 @[PositEncode.scala 47:19]
    wire _T_25 : SInt<4> @[UnpackedPosit.scala 25:22]
    node _T_26 = bits(io.in.exponent, 4, 1) @[UnpackedPosit.scala 26:38]
    node _T_28 = sub(_T_26, UInt<3>("h06")) @[UnpackedPosit.scala 26:92]
    node _T_29 = asUInt(_T_28) @[UnpackedPosit.scala 26:92]
    node _T_30 = tail(_T_29, 1) @[UnpackedPosit.scala 26:92]
    node _T_31 = asSInt(_T_30) @[UnpackedPosit.scala 27:56]
    _T_25 <= _T_31 @[UnpackedPosit.scala 26:12]
    signedRegime <= _T_25 @[PositEncode.scala 53:16]
    node _T_33 = geq(signedRegime, asSInt(UInt<1>("h00"))) @[PositEncode.scala 55:30]
    posRegime <= _T_33 @[PositEncode.scala 55:13]
    node _T_35 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 65:18]
    when _T_35 : @[PositEncode.scala 65:27]
      node _T_36 = bits(signedRegime, 2, 0) @[PositEncode.scala 66:30]
      shiftBits <= _T_36 @[PositEncode.scala 66:15]
      skip @[PositEncode.scala 65:27]
    else : @[PositEncode.scala 68:16]
      node _T_37 = bits(signedRegime, 2, 0) @[PositEncode.scala 72:31]
      node _T_38 = not(_T_37) @[PositEncode.scala 72:18]
      shiftBits <= _T_38 @[PositEncode.scala 72:15]
      skip @[PositEncode.scala 68:16]
    wire outBitsVec : UInt<1>[8] @[PositEncode.scala 75:24]
    node _T_52 = cat(outBitsVec[1], outBitsVec[0]) @[PositEncode.scala 76:29]
    node _T_53 = cat(outBitsVec[3], outBitsVec[2]) @[PositEncode.scala 76:29]
    node _T_54 = cat(_T_53, _T_52) @[PositEncode.scala 76:29]
    node _T_55 = cat(outBitsVec[5], outBitsVec[4]) @[PositEncode.scala 76:29]
    node _T_56 = cat(outBitsVec[7], outBitsVec[6]) @[PositEncode.scala 76:29]
    node _T_57 = cat(_T_56, _T_55) @[PositEncode.scala 76:29]
    node _T_58 = cat(_T_57, _T_54) @[PositEncode.scala 76:29]
    io.out.bits <= _T_58 @[PositEncode.scala 76:15]
    when io.in.isZero : @[PositEncode.scala 77:22]
      outBitsVec[0] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[1] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[2] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[3] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[4] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[5] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[6] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[7] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      skip @[PositEncode.scala 77:22]
    else : @[PositEncode.scala 81:28]
      when io.in.isInf : @[PositEncode.scala 81:28]
        node _T_70 = cat(UInt<1>("h01"), UInt<7>("h00")) @[Cat.scala 30:58]
        node _T_71 = bits(_T_70, 0, 0) @[PositEncode.scala 83:61]
        node _T_72 = bits(_T_70, 1, 1) @[PositEncode.scala 83:61]
        node _T_73 = bits(_T_70, 2, 2) @[PositEncode.scala 83:61]
        node _T_74 = bits(_T_70, 3, 3) @[PositEncode.scala 83:61]
        node _T_75 = bits(_T_70, 4, 4) @[PositEncode.scala 83:61]
        node _T_76 = bits(_T_70, 5, 5) @[PositEncode.scala 83:61]
        node _T_77 = bits(_T_70, 6, 6) @[PositEncode.scala 83:61]
        node _T_78 = bits(_T_70, 7, 7) @[PositEncode.scala 83:61]
        outBitsVec[0] <= _T_71 @[PositEncode.scala 83:16]
        outBitsVec[1] <= _T_72 @[PositEncode.scala 83:16]
        outBitsVec[2] <= _T_73 @[PositEncode.scala 83:16]
        outBitsVec[3] <= _T_74 @[PositEncode.scala 83:16]
        outBitsVec[4] <= _T_75 @[PositEncode.scala 83:16]
        outBitsVec[5] <= _T_76 @[PositEncode.scala 83:16]
        outBitsVec[6] <= _T_77 @[PositEncode.scala 83:16]
        outBitsVec[7] <= _T_78 @[PositEncode.scala 83:16]
        skip @[PositEncode.scala 81:28]
      else : @[PositEncode.scala 85:16]
        outBitsVec[7] <= io.in.sign @[PositEncode.scala 86:25]
        node _T_79 = bits(esAndFractionShifted, 6, 6) @[PositEncode.scala 88:44]
        outBitsVec[6] <= _T_79 @[PositEncode.scala 88:21]
        node _T_80 = bits(esAndFractionShifted, 5, 5) @[PositEncode.scala 88:44]
        outBitsVec[5] <= _T_80 @[PositEncode.scala 88:21]
        node _T_81 = bits(esAndFractionShifted, 4, 4) @[PositEncode.scala 88:44]
        outBitsVec[4] <= _T_81 @[PositEncode.scala 88:21]
        node _T_82 = bits(esAndFractionShifted, 3, 3) @[PositEncode.scala 88:44]
        outBitsVec[3] <= _T_82 @[PositEncode.scala 88:21]
        node _T_83 = bits(esAndFractionShifted, 2, 2) @[PositEncode.scala 88:44]
        outBitsVec[2] <= _T_83 @[PositEncode.scala 88:21]
        node _T_84 = bits(esAndFractionShifted, 1, 1) @[PositEncode.scala 88:44]
        outBitsVec[1] <= _T_84 @[PositEncode.scala 88:21]
        node _T_85 = bits(esAndFractionShifted, 0, 0) @[PositEncode.scala 88:44]
        outBitsVec[0] <= _T_85 @[PositEncode.scala 88:21]
        skip @[PositEncode.scala 85:16]
    
  module CountLeadingZerosTree : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<2>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<2> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<2> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[2] @[PositDef.scala 291:29]
    node _T_21 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_21 @[PositDef.scala 296:24]
    node _T_22 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = cat(rCountExtendVec[1], rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_23 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_24 = bits(io.left, 1, 1) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_24 @[PositDef.scala 307:23]
    node _T_25 = bits(io.left, 0, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_25 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_1 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_26 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_26 @[PositDef.scala 316:24]
    node _T_27 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_27 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_28 = bits(lCount, 1, 1) @[PositDef.scala 324:16]
    node _T_29 = bits(rCountExtend, 1, 1) @[PositDef.scala 324:55]
    node _T_30 = and(_T_28, _T_29) @[PositDef.scala 324:40]
    when _T_30 : @[PositDef.scala 324:80]
      node _T_33 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_33 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_34 = bits(lCount, 1, 1) @[PositDef.scala 326:24]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_36 : @[PositDef.scala 326:51]
        node _T_38 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_38 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_40 = bits(rCountExtend, 0, 0) @[PositDef.scala 329:43]
        node _T_41 = cat(UInt<2>("h01"), _T_40) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZerosTree_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_4 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<4>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<3> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<3> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[3] @[PositDef.scala 291:29]
    node _T_22 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_23 @[PositDef.scala 296:24]
    rCountExtendVec[2] <= UInt<1>("h00") @[PositDef.scala 300:24]
    node _T_25 = cat(rCountExtendVec[2], rCountExtendVec[1]) @[PositDef.scala 303:35]
    node _T_26 = cat(_T_25, rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_26 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_2 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_27 = bits(io.left, 3, 2) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_27 @[PositDef.scala 307:23]
    node _T_28 = bits(io.left, 1, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_28 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_3 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_29 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_29 @[PositDef.scala 316:24]
    node _T_30 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_30 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_31 = bits(lCount, 2, 2) @[PositDef.scala 324:16]
    node _T_32 = bits(rCountExtend, 2, 2) @[PositDef.scala 324:55]
    node _T_33 = and(_T_31, _T_32) @[PositDef.scala 324:40]
    when _T_33 : @[PositDef.scala 324:80]
      node _T_36 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_36 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_37 = bits(lCount, 2, 2) @[PositDef.scala 326:24]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_39 : @[PositDef.scala 326:51]
        node _T_41 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_43 = bits(rCountExtend, 1, 0) @[PositDef.scala 329:43]
        node _T_44 = cat(UInt<2>("h01"), _T_43) @[Cat.scala 30:58]
        io.out <= _T_44 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZeros : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<6>, out : UInt<3>}
    
    wire inPad : UInt<6> @[PositDef.scala 363:19]
    wire inPadVec : UInt<1>[6] @[PositDef.scala 364:22]
    node _T_21 = bits(io.in, 5, 5) @[PositDef.scala 372:25]
    inPadVec[5] <= _T_21 @[PositDef.scala 372:17]
    node _T_22 = bits(io.in, 4, 4) @[PositDef.scala 372:25]
    inPadVec[4] <= _T_22 @[PositDef.scala 372:17]
    node _T_23 = bits(io.in, 3, 3) @[PositDef.scala 372:25]
    inPadVec[3] <= _T_23 @[PositDef.scala 372:17]
    node _T_24 = bits(io.in, 2, 2) @[PositDef.scala 372:25]
    inPadVec[2] <= _T_24 @[PositDef.scala 372:17]
    node _T_25 = bits(io.in, 1, 1) @[PositDef.scala 372:25]
    inPadVec[1] <= _T_25 @[PositDef.scala 372:17]
    node _T_26 = bits(io.in, 0, 0) @[PositDef.scala 372:25]
    inPadVec[0] <= _T_26 @[PositDef.scala 372:17]
    node _T_27 = cat(inPadVec[2], inPadVec[1]) @[PositDef.scala 374:21]
    node _T_28 = cat(_T_27, inPadVec[0]) @[PositDef.scala 374:21]
    node _T_29 = cat(inPadVec[5], inPadVec[4]) @[PositDef.scala 374:21]
    node _T_30 = cat(_T_29, inPadVec[3]) @[PositDef.scala 374:21]
    node _T_31 = cat(_T_30, _T_28) @[PositDef.scala 374:21]
    inPad <= _T_31 @[PositDef.scala 374:9]
    inst tree of CountLeadingZerosTree_4 @[PositDef.scala 375:20]
    tree.clock <= clock
    tree.reset <= reset
    node _T_32 = bits(inPad, 5, 2) @[PositDef.scala 376:24]
    tree.io.left <= _T_32 @[PositDef.scala 376:16]
    node _T_33 = bits(io.in, 1, 0) @[PositDef.scala 377:25]
    tree.io.right <= _T_33 @[PositDef.scala 377:17]
    io.out <= tree.io.out @[PositDef.scala 378:10]
    
  module PositDecode : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {bits : UInt<8>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    wire remainderBits : UInt<7> @[PositDecode.scala 22:27]
    wire remainderXor : UInt<6> @[PositDecode.scala 27:26]
    wire remainderXorVec : UInt<1>[6] @[PositDecode.scala 28:29]
    wire cl0 : UInt<3> @[PositDecode.scala 31:17]
    wire regimePosOrZero : UInt<1> @[PositDecode.scala 35:29]
    wire isSpecial : UInt<1> @[PositDecode.scala 38:23]
    wire unsignedRegime : UInt<4> @[PositDecode.scala 41:28]
    wire regimeShiftMinus2 : UInt<3> @[PositDecode.scala 44:31]
    wire esAndFractionBits : UInt<5> @[PositDecode.scala 48:31]
    node _T_28 = bits(remainderBits, 6, 6) @[PositDecode.scala 54:44]
    node _T_29 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:63]
    node _T_30 = xor(_T_28, _T_29) @[PositDecode.scala 54:48]
    remainderXorVec[5] <= _T_30 @[PositDecode.scala 54:28]
    node _T_31 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:44]
    node _T_32 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:63]
    node _T_33 = xor(_T_31, _T_32) @[PositDecode.scala 54:48]
    remainderXorVec[4] <= _T_33 @[PositDecode.scala 54:28]
    node _T_34 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:44]
    node _T_35 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:63]
    node _T_36 = xor(_T_34, _T_35) @[PositDecode.scala 54:48]
    remainderXorVec[3] <= _T_36 @[PositDecode.scala 54:28]
    node _T_37 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:44]
    node _T_38 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:63]
    node _T_39 = xor(_T_37, _T_38) @[PositDecode.scala 54:48]
    remainderXorVec[2] <= _T_39 @[PositDecode.scala 54:28]
    node _T_40 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:44]
    node _T_41 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:63]
    node _T_42 = xor(_T_40, _T_41) @[PositDecode.scala 54:48]
    remainderXorVec[1] <= _T_42 @[PositDecode.scala 54:28]
    node _T_43 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:44]
    node _T_44 = bits(remainderBits, 0, 0) @[PositDecode.scala 54:63]
    node _T_45 = xor(_T_43, _T_44) @[PositDecode.scala 54:48]
    remainderXorVec[0] <= _T_45 @[PositDecode.scala 54:28]
    node _T_46 = cat(remainderXorVec[2], remainderXorVec[1]) @[PositDecode.scala 59:35]
    node _T_47 = cat(_T_46, remainderXorVec[0]) @[PositDecode.scala 59:35]
    node _T_48 = cat(remainderXorVec[5], remainderXorVec[4]) @[PositDecode.scala 59:35]
    node _T_49 = cat(_T_48, remainderXorVec[3]) @[PositDecode.scala 59:35]
    node _T_50 = cat(_T_49, _T_47) @[PositDecode.scala 59:35]
    remainderXor <= _T_50 @[PositDecode.scala 59:16]
    inst countingLeadingZeros of CountLeadingZeros @[PositDecode.scala 64:36]
    countingLeadingZeros.clock <= clock
    countingLeadingZeros.reset <= reset
    countingLeadingZeros.io.in <= remainderXor @[PositDecode.scala 65:30]
    cl0 <= countingLeadingZeros.io.out @[PositDecode.scala 66:7]
    node _T_51 = bits(remainderBits, 4, 0) @[PositDecode.scala 69:37]
    node _T_52 = dshl(_T_51, regimeShiftMinus2) @[PositDecode.scala 69:72]
    esAndFractionBits <= _T_52 @[PositDecode.scala 69:21]
    node _T_53 = bits(io.in.bits, 6, 0) @[PositDecode.scala 72:30]
    remainderBits <= _T_53 @[PositDecode.scala 72:17]
    node _T_54 = bits(remainderBits, 6, 6) @[PositDecode.scala 74:35]
    regimePosOrZero <= _T_54 @[PositDecode.scala 74:19]
    node _T_56 = neq(remainderBits, UInt<1>("h00")) @[PositDecode.scala 76:31]
    node _T_58 = eq(_T_56, UInt<1>("h00")) @[PositDecode.scala 76:16]
    isSpecial <= _T_58 @[PositDecode.scala 76:13]
    wire cl0extended : UInt<4> @[PositDecode.scala 79:25]
    cl0extended <= cl0 @[PositDecode.scala 80:15]
    node _T_61 = eq(isSpecial, UInt<1>("h01")) @[PositDecode.scala 82:19]
    when _T_61 : @[PositDecode.scala 82:28]
      unsignedRegime <= UInt<4>("h00") @[PositDecode.scala 83:20]
      skip @[PositDecode.scala 82:28]
    else : @[PositDecode.scala 84:16]
      node _T_64 = eq(regimePosOrZero, UInt<1>("h01")) @[PositDecode.scala 85:28]
      node _T_65 = bits(_T_64, 0, 0) @[PositDecode.scala 85:43]
      when _T_65 : @[PositDecode.scala 85:47]
        unsignedRegime <= cl0extended @[PositDecode.scala 86:22]
        skip @[PositDecode.scala 85:47]
      else : @[PositDecode.scala 87:18]
        node _T_67 = not(cl0) @[PositDecode.scala 89:87]
        node _T_68 = add(UInt<3>("h06"), _T_67) @[PositDecode.scala 89:85]
        node _T_69 = tail(_T_68, 1) @[PositDecode.scala 89:85]
        unsignedRegime <= _T_69 @[PositDecode.scala 89:22]
        skip @[PositDecode.scala 87:18]
      skip @[PositDecode.scala 84:16]
    regimeShiftMinus2 <= cl0 @[PositDecode.scala 120:21]
    node _T_70 = bits(io.in.bits, 7, 7) @[PositDecode.scala 122:29]
    node _T_71 = bits(isSpecial, 0, 0) @[PositDecode.scala 122:60]
    node _T_72 = and(_T_70, _T_71) @[PositDecode.scala 122:41]
    io.out.isInf <= _T_72 @[PositDecode.scala 122:16]
    node _T_73 = bits(io.in.bits, 7, 7) @[PositDecode.scala 123:31]
    node _T_75 = eq(_T_73, UInt<1>("h00")) @[PositDecode.scala 123:20]
    node _T_76 = bits(isSpecial, 0, 0) @[PositDecode.scala 123:62]
    node _T_77 = and(_T_75, _T_76) @[PositDecode.scala 123:43]
    io.out.isZero <= _T_77 @[PositDecode.scala 123:17]
    node _T_79 = eq(isSpecial, UInt<1>("h00")) @[PositDecode.scala 124:18]
    node _T_80 = bits(io.in.bits, 7, 7) @[PositDecode.scala 124:42]
    node _T_81 = and(_T_79, _T_80) @[PositDecode.scala 124:29]
    io.out.sign <= _T_81 @[PositDecode.scala 124:15]
    wire _T_83 : UInt<1> @[PositDecode.scala 128:22]
    node _T_84 = bits(esAndFractionBits, 4, 4) @[PositDecode.scala 132:32]
    _T_83 <= _T_84 @[PositDecode.scala 132:12]
    node _T_85 = bits(esAndFractionBits, 3, 0) @[PositDecode.scala 134:41]
    io.out.fraction <= _T_85 @[PositDecode.scala 134:21]
    node _T_86 = cat(unsignedRegime, _T_83) @[Cat.scala 30:58]
    io.out.exponent <= _T_86 @[PositDecode.scala 135:21]
    
  module PositEncode_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {bits : UInt<8>}}
    
    wire signedRegime : SInt<4> @[PositEncode.scala 22:26]
    wire shiftBits : UInt<3> @[PositEncode.scala 24:23]
    wire posRegime : UInt<1> @[PositEncode.scala 26:23]
    wire esAndFraction : SInt<7> @[PositEncode.scala 28:27]
    wire esAndFractionShifted : SInt<7> @[PositEncode.scala 30:34]
    node _T_14 = dshr(esAndFraction, shiftBits) @[PositEncode.scala 37:41]
    esAndFractionShifted <= _T_14 @[PositEncode.scala 37:24]
    wire firstBits : UInt<2> @[PositEncode.scala 39:23]
    node _T_17 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 40:18]
    when _T_17 : @[PositEncode.scala 40:27]
      firstBits <= UInt<2>("h02") @[PositEncode.scala 41:15]
      skip @[PositEncode.scala 40:27]
    else : @[PositEncode.scala 42:16]
      firstBits <= UInt<1>("h01") @[PositEncode.scala 43:15]
      skip @[PositEncode.scala 42:16]
    node _T_20 = bits(io.in.exponent, 0, 0) @[PositEncode.scala 47:55]
    node _T_21 = cat(_T_20, io.in.fraction) @[Cat.scala 30:58]
    node _T_22 = cat(firstBits, _T_21) @[Cat.scala 30:58]
    node _T_23 = asSInt(_T_22) @[PositEncode.scala 47:83]
    esAndFraction <= _T_23 @[PositEncode.scala 47:19]
    wire _T_25 : SInt<4> @[UnpackedPosit.scala 25:22]
    node _T_26 = bits(io.in.exponent, 4, 1) @[UnpackedPosit.scala 26:38]
    node _T_28 = sub(_T_26, UInt<3>("h06")) @[UnpackedPosit.scala 26:92]
    node _T_29 = asUInt(_T_28) @[UnpackedPosit.scala 26:92]
    node _T_30 = tail(_T_29, 1) @[UnpackedPosit.scala 26:92]
    node _T_31 = asSInt(_T_30) @[UnpackedPosit.scala 27:56]
    _T_25 <= _T_31 @[UnpackedPosit.scala 26:12]
    signedRegime <= _T_25 @[PositEncode.scala 53:16]
    node _T_33 = geq(signedRegime, asSInt(UInt<1>("h00"))) @[PositEncode.scala 55:30]
    posRegime <= _T_33 @[PositEncode.scala 55:13]
    node _T_35 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 65:18]
    when _T_35 : @[PositEncode.scala 65:27]
      node _T_36 = bits(signedRegime, 2, 0) @[PositEncode.scala 66:30]
      shiftBits <= _T_36 @[PositEncode.scala 66:15]
      skip @[PositEncode.scala 65:27]
    else : @[PositEncode.scala 68:16]
      node _T_37 = bits(signedRegime, 2, 0) @[PositEncode.scala 72:31]
      node _T_38 = not(_T_37) @[PositEncode.scala 72:18]
      shiftBits <= _T_38 @[PositEncode.scala 72:15]
      skip @[PositEncode.scala 68:16]
    wire outBitsVec : UInt<1>[8] @[PositEncode.scala 75:24]
    node _T_52 = cat(outBitsVec[1], outBitsVec[0]) @[PositEncode.scala 76:29]
    node _T_53 = cat(outBitsVec[3], outBitsVec[2]) @[PositEncode.scala 76:29]
    node _T_54 = cat(_T_53, _T_52) @[PositEncode.scala 76:29]
    node _T_55 = cat(outBitsVec[5], outBitsVec[4]) @[PositEncode.scala 76:29]
    node _T_56 = cat(outBitsVec[7], outBitsVec[6]) @[PositEncode.scala 76:29]
    node _T_57 = cat(_T_56, _T_55) @[PositEncode.scala 76:29]
    node _T_58 = cat(_T_57, _T_54) @[PositEncode.scala 76:29]
    io.out.bits <= _T_58 @[PositEncode.scala 76:15]
    when io.in.isZero : @[PositEncode.scala 77:22]
      outBitsVec[0] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[1] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[2] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[3] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[4] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[5] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[6] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[7] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      skip @[PositEncode.scala 77:22]
    else : @[PositEncode.scala 81:28]
      when io.in.isInf : @[PositEncode.scala 81:28]
        node _T_70 = cat(UInt<1>("h01"), UInt<7>("h00")) @[Cat.scala 30:58]
        node _T_71 = bits(_T_70, 0, 0) @[PositEncode.scala 83:61]
        node _T_72 = bits(_T_70, 1, 1) @[PositEncode.scala 83:61]
        node _T_73 = bits(_T_70, 2, 2) @[PositEncode.scala 83:61]
        node _T_74 = bits(_T_70, 3, 3) @[PositEncode.scala 83:61]
        node _T_75 = bits(_T_70, 4, 4) @[PositEncode.scala 83:61]
        node _T_76 = bits(_T_70, 5, 5) @[PositEncode.scala 83:61]
        node _T_77 = bits(_T_70, 6, 6) @[PositEncode.scala 83:61]
        node _T_78 = bits(_T_70, 7, 7) @[PositEncode.scala 83:61]
        outBitsVec[0] <= _T_71 @[PositEncode.scala 83:16]
        outBitsVec[1] <= _T_72 @[PositEncode.scala 83:16]
        outBitsVec[2] <= _T_73 @[PositEncode.scala 83:16]
        outBitsVec[3] <= _T_74 @[PositEncode.scala 83:16]
        outBitsVec[4] <= _T_75 @[PositEncode.scala 83:16]
        outBitsVec[5] <= _T_76 @[PositEncode.scala 83:16]
        outBitsVec[6] <= _T_77 @[PositEncode.scala 83:16]
        outBitsVec[7] <= _T_78 @[PositEncode.scala 83:16]
        skip @[PositEncode.scala 81:28]
      else : @[PositEncode.scala 85:16]
        outBitsVec[7] <= io.in.sign @[PositEncode.scala 86:25]
        node _T_79 = bits(esAndFractionShifted, 6, 6) @[PositEncode.scala 88:44]
        outBitsVec[6] <= _T_79 @[PositEncode.scala 88:21]
        node _T_80 = bits(esAndFractionShifted, 5, 5) @[PositEncode.scala 88:44]
        outBitsVec[5] <= _T_80 @[PositEncode.scala 88:21]
        node _T_81 = bits(esAndFractionShifted, 4, 4) @[PositEncode.scala 88:44]
        outBitsVec[4] <= _T_81 @[PositEncode.scala 88:21]
        node _T_82 = bits(esAndFractionShifted, 3, 3) @[PositEncode.scala 88:44]
        outBitsVec[3] <= _T_82 @[PositEncode.scala 88:21]
        node _T_83 = bits(esAndFractionShifted, 2, 2) @[PositEncode.scala 88:44]
        outBitsVec[2] <= _T_83 @[PositEncode.scala 88:21]
        node _T_84 = bits(esAndFractionShifted, 1, 1) @[PositEncode.scala 88:44]
        outBitsVec[1] <= _T_84 @[PositEncode.scala 88:21]
        node _T_85 = bits(esAndFractionShifted, 0, 0) @[PositEncode.scala 88:44]
        outBitsVec[0] <= _T_85 @[PositEncode.scala 88:21]
        skip @[PositEncode.scala 85:16]
    
  module CountLeadingZerosTree_5 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_6 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_7 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<2>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<2> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<2> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[2] @[PositDef.scala 291:29]
    node _T_21 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_21 @[PositDef.scala 296:24]
    node _T_22 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = cat(rCountExtendVec[1], rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_23 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_5 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_24 = bits(io.left, 1, 1) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_24 @[PositDef.scala 307:23]
    node _T_25 = bits(io.left, 0, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_25 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_6 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_26 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_26 @[PositDef.scala 316:24]
    node _T_27 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_27 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_28 = bits(lCount, 1, 1) @[PositDef.scala 324:16]
    node _T_29 = bits(rCountExtend, 1, 1) @[PositDef.scala 324:55]
    node _T_30 = and(_T_28, _T_29) @[PositDef.scala 324:40]
    when _T_30 : @[PositDef.scala 324:80]
      node _T_33 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_33 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_34 = bits(lCount, 1, 1) @[PositDef.scala 326:24]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_36 : @[PositDef.scala 326:51]
        node _T_38 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_38 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_40 = bits(rCountExtend, 0, 0) @[PositDef.scala 329:43]
        node _T_41 = cat(UInt<2>("h01"), _T_40) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZerosTree_8 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_9 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<4>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<3> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<3> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[3] @[PositDef.scala 291:29]
    node _T_22 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_23 @[PositDef.scala 296:24]
    rCountExtendVec[2] <= UInt<1>("h00") @[PositDef.scala 300:24]
    node _T_25 = cat(rCountExtendVec[2], rCountExtendVec[1]) @[PositDef.scala 303:35]
    node _T_26 = cat(_T_25, rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_26 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_7 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_27 = bits(io.left, 3, 2) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_27 @[PositDef.scala 307:23]
    node _T_28 = bits(io.left, 1, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_28 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_8 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_29 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_29 @[PositDef.scala 316:24]
    node _T_30 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_30 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_31 = bits(lCount, 2, 2) @[PositDef.scala 324:16]
    node _T_32 = bits(rCountExtend, 2, 2) @[PositDef.scala 324:55]
    node _T_33 = and(_T_31, _T_32) @[PositDef.scala 324:40]
    when _T_33 : @[PositDef.scala 324:80]
      node _T_36 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_36 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_37 = bits(lCount, 2, 2) @[PositDef.scala 326:24]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_39 : @[PositDef.scala 326:51]
        node _T_41 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_43 = bits(rCountExtend, 1, 0) @[PositDef.scala 329:43]
        node _T_44 = cat(UInt<2>("h01"), _T_43) @[Cat.scala 30:58]
        io.out <= _T_44 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZeros_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<6>, out : UInt<3>}
    
    wire inPad : UInt<6> @[PositDef.scala 363:19]
    wire inPadVec : UInt<1>[6] @[PositDef.scala 364:22]
    node _T_21 = bits(io.in, 5, 5) @[PositDef.scala 372:25]
    inPadVec[5] <= _T_21 @[PositDef.scala 372:17]
    node _T_22 = bits(io.in, 4, 4) @[PositDef.scala 372:25]
    inPadVec[4] <= _T_22 @[PositDef.scala 372:17]
    node _T_23 = bits(io.in, 3, 3) @[PositDef.scala 372:25]
    inPadVec[3] <= _T_23 @[PositDef.scala 372:17]
    node _T_24 = bits(io.in, 2, 2) @[PositDef.scala 372:25]
    inPadVec[2] <= _T_24 @[PositDef.scala 372:17]
    node _T_25 = bits(io.in, 1, 1) @[PositDef.scala 372:25]
    inPadVec[1] <= _T_25 @[PositDef.scala 372:17]
    node _T_26 = bits(io.in, 0, 0) @[PositDef.scala 372:25]
    inPadVec[0] <= _T_26 @[PositDef.scala 372:17]
    node _T_27 = cat(inPadVec[2], inPadVec[1]) @[PositDef.scala 374:21]
    node _T_28 = cat(_T_27, inPadVec[0]) @[PositDef.scala 374:21]
    node _T_29 = cat(inPadVec[5], inPadVec[4]) @[PositDef.scala 374:21]
    node _T_30 = cat(_T_29, inPadVec[3]) @[PositDef.scala 374:21]
    node _T_31 = cat(_T_30, _T_28) @[PositDef.scala 374:21]
    inPad <= _T_31 @[PositDef.scala 374:9]
    inst tree of CountLeadingZerosTree_9 @[PositDef.scala 375:20]
    tree.clock <= clock
    tree.reset <= reset
    node _T_32 = bits(inPad, 5, 2) @[PositDef.scala 376:24]
    tree.io.left <= _T_32 @[PositDef.scala 376:16]
    node _T_33 = bits(io.in, 1, 0) @[PositDef.scala 377:25]
    tree.io.right <= _T_33 @[PositDef.scala 377:17]
    io.out <= tree.io.out @[PositDef.scala 378:10]
    
  module PositDecode_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {bits : UInt<8>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    wire remainderBits : UInt<7> @[PositDecode.scala 22:27]
    wire remainderXor : UInt<6> @[PositDecode.scala 27:26]
    wire remainderXorVec : UInt<1>[6] @[PositDecode.scala 28:29]
    wire cl0 : UInt<3> @[PositDecode.scala 31:17]
    wire regimePosOrZero : UInt<1> @[PositDecode.scala 35:29]
    wire isSpecial : UInt<1> @[PositDecode.scala 38:23]
    wire unsignedRegime : UInt<4> @[PositDecode.scala 41:28]
    wire regimeShiftMinus2 : UInt<3> @[PositDecode.scala 44:31]
    wire esAndFractionBits : UInt<5> @[PositDecode.scala 48:31]
    node _T_28 = bits(remainderBits, 6, 6) @[PositDecode.scala 54:44]
    node _T_29 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:63]
    node _T_30 = xor(_T_28, _T_29) @[PositDecode.scala 54:48]
    remainderXorVec[5] <= _T_30 @[PositDecode.scala 54:28]
    node _T_31 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:44]
    node _T_32 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:63]
    node _T_33 = xor(_T_31, _T_32) @[PositDecode.scala 54:48]
    remainderXorVec[4] <= _T_33 @[PositDecode.scala 54:28]
    node _T_34 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:44]
    node _T_35 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:63]
    node _T_36 = xor(_T_34, _T_35) @[PositDecode.scala 54:48]
    remainderXorVec[3] <= _T_36 @[PositDecode.scala 54:28]
    node _T_37 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:44]
    node _T_38 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:63]
    node _T_39 = xor(_T_37, _T_38) @[PositDecode.scala 54:48]
    remainderXorVec[2] <= _T_39 @[PositDecode.scala 54:28]
    node _T_40 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:44]
    node _T_41 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:63]
    node _T_42 = xor(_T_40, _T_41) @[PositDecode.scala 54:48]
    remainderXorVec[1] <= _T_42 @[PositDecode.scala 54:28]
    node _T_43 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:44]
    node _T_44 = bits(remainderBits, 0, 0) @[PositDecode.scala 54:63]
    node _T_45 = xor(_T_43, _T_44) @[PositDecode.scala 54:48]
    remainderXorVec[0] <= _T_45 @[PositDecode.scala 54:28]
    node _T_46 = cat(remainderXorVec[2], remainderXorVec[1]) @[PositDecode.scala 59:35]
    node _T_47 = cat(_T_46, remainderXorVec[0]) @[PositDecode.scala 59:35]
    node _T_48 = cat(remainderXorVec[5], remainderXorVec[4]) @[PositDecode.scala 59:35]
    node _T_49 = cat(_T_48, remainderXorVec[3]) @[PositDecode.scala 59:35]
    node _T_50 = cat(_T_49, _T_47) @[PositDecode.scala 59:35]
    remainderXor <= _T_50 @[PositDecode.scala 59:16]
    inst countingLeadingZeros of CountLeadingZeros_1 @[PositDecode.scala 64:36]
    countingLeadingZeros.clock <= clock
    countingLeadingZeros.reset <= reset
    countingLeadingZeros.io.in <= remainderXor @[PositDecode.scala 65:30]
    cl0 <= countingLeadingZeros.io.out @[PositDecode.scala 66:7]
    node _T_51 = bits(remainderBits, 4, 0) @[PositDecode.scala 69:37]
    node _T_52 = dshl(_T_51, regimeShiftMinus2) @[PositDecode.scala 69:72]
    esAndFractionBits <= _T_52 @[PositDecode.scala 69:21]
    node _T_53 = bits(io.in.bits, 6, 0) @[PositDecode.scala 72:30]
    remainderBits <= _T_53 @[PositDecode.scala 72:17]
    node _T_54 = bits(remainderBits, 6, 6) @[PositDecode.scala 74:35]
    regimePosOrZero <= _T_54 @[PositDecode.scala 74:19]
    node _T_56 = neq(remainderBits, UInt<1>("h00")) @[PositDecode.scala 76:31]
    node _T_58 = eq(_T_56, UInt<1>("h00")) @[PositDecode.scala 76:16]
    isSpecial <= _T_58 @[PositDecode.scala 76:13]
    wire cl0extended : UInt<4> @[PositDecode.scala 79:25]
    cl0extended <= cl0 @[PositDecode.scala 80:15]
    node _T_61 = eq(isSpecial, UInt<1>("h01")) @[PositDecode.scala 82:19]
    when _T_61 : @[PositDecode.scala 82:28]
      unsignedRegime <= UInt<4>("h00") @[PositDecode.scala 83:20]
      skip @[PositDecode.scala 82:28]
    else : @[PositDecode.scala 84:16]
      node _T_64 = eq(regimePosOrZero, UInt<1>("h01")) @[PositDecode.scala 85:28]
      node _T_65 = bits(_T_64, 0, 0) @[PositDecode.scala 85:43]
      when _T_65 : @[PositDecode.scala 85:47]
        unsignedRegime <= cl0extended @[PositDecode.scala 86:22]
        skip @[PositDecode.scala 85:47]
      else : @[PositDecode.scala 87:18]
        node _T_67 = not(cl0) @[PositDecode.scala 89:87]
        node _T_68 = add(UInt<3>("h06"), _T_67) @[PositDecode.scala 89:85]
        node _T_69 = tail(_T_68, 1) @[PositDecode.scala 89:85]
        unsignedRegime <= _T_69 @[PositDecode.scala 89:22]
        skip @[PositDecode.scala 87:18]
      skip @[PositDecode.scala 84:16]
    regimeShiftMinus2 <= cl0 @[PositDecode.scala 120:21]
    node _T_70 = bits(io.in.bits, 7, 7) @[PositDecode.scala 122:29]
    node _T_71 = bits(isSpecial, 0, 0) @[PositDecode.scala 122:60]
    node _T_72 = and(_T_70, _T_71) @[PositDecode.scala 122:41]
    io.out.isInf <= _T_72 @[PositDecode.scala 122:16]
    node _T_73 = bits(io.in.bits, 7, 7) @[PositDecode.scala 123:31]
    node _T_75 = eq(_T_73, UInt<1>("h00")) @[PositDecode.scala 123:20]
    node _T_76 = bits(isSpecial, 0, 0) @[PositDecode.scala 123:62]
    node _T_77 = and(_T_75, _T_76) @[PositDecode.scala 123:43]
    io.out.isZero <= _T_77 @[PositDecode.scala 123:17]
    node _T_79 = eq(isSpecial, UInt<1>("h00")) @[PositDecode.scala 124:18]
    node _T_80 = bits(io.in.bits, 7, 7) @[PositDecode.scala 124:42]
    node _T_81 = and(_T_79, _T_80) @[PositDecode.scala 124:29]
    io.out.sign <= _T_81 @[PositDecode.scala 124:15]
    wire _T_83 : UInt<1> @[PositDecode.scala 128:22]
    node _T_84 = bits(esAndFractionBits, 4, 4) @[PositDecode.scala 132:32]
    _T_83 <= _T_84 @[PositDecode.scala 132:12]
    node _T_85 = bits(esAndFractionBits, 3, 0) @[PositDecode.scala 134:41]
    io.out.fraction <= _T_85 @[PositDecode.scala 134:21]
    node _T_86 = cat(unsignedRegime, _T_83) @[Cat.scala 30:58]
    io.out.exponent <= _T_86 @[PositDecode.scala 135:21]
    
  module CountLeadingZerosTree_10 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_11 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_12 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<2>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<2> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<2> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[2] @[PositDef.scala 291:29]
    node _T_21 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_21 @[PositDef.scala 296:24]
    node _T_22 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = cat(rCountExtendVec[1], rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_23 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_10 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_24 = bits(io.left, 1, 1) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_24 @[PositDef.scala 307:23]
    node _T_25 = bits(io.left, 0, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_25 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_11 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_26 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_26 @[PositDef.scala 316:24]
    node _T_27 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_27 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_28 = bits(lCount, 1, 1) @[PositDef.scala 324:16]
    node _T_29 = bits(rCountExtend, 1, 1) @[PositDef.scala 324:55]
    node _T_30 = and(_T_28, _T_29) @[PositDef.scala 324:40]
    when _T_30 : @[PositDef.scala 324:80]
      node _T_33 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_33 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_34 = bits(lCount, 1, 1) @[PositDef.scala 326:24]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_36 : @[PositDef.scala 326:51]
        node _T_38 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_38 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_40 = bits(rCountExtend, 0, 0) @[PositDef.scala 329:43]
        node _T_41 = cat(UInt<2>("h01"), _T_40) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZerosTree_13 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_14 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<4>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<3> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<3> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[3] @[PositDef.scala 291:29]
    node _T_22 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_23 @[PositDef.scala 296:24]
    rCountExtendVec[2] <= UInt<1>("h00") @[PositDef.scala 300:24]
    node _T_25 = cat(rCountExtendVec[2], rCountExtendVec[1]) @[PositDef.scala 303:35]
    node _T_26 = cat(_T_25, rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_26 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_12 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_27 = bits(io.left, 3, 2) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_27 @[PositDef.scala 307:23]
    node _T_28 = bits(io.left, 1, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_28 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_13 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_29 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_29 @[PositDef.scala 316:24]
    node _T_30 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_30 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_31 = bits(lCount, 2, 2) @[PositDef.scala 324:16]
    node _T_32 = bits(rCountExtend, 2, 2) @[PositDef.scala 324:55]
    node _T_33 = and(_T_31, _T_32) @[PositDef.scala 324:40]
    when _T_33 : @[PositDef.scala 324:80]
      node _T_36 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_36 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_37 = bits(lCount, 2, 2) @[PositDef.scala 326:24]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_39 : @[PositDef.scala 326:51]
        node _T_41 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_43 = bits(rCountExtend, 1, 0) @[PositDef.scala 329:43]
        node _T_44 = cat(UInt<2>("h01"), _T_43) @[Cat.scala 30:58]
        io.out <= _T_44 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZeros_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<6>, out : UInt<3>}
    
    wire inPad : UInt<6> @[PositDef.scala 363:19]
    wire inPadVec : UInt<1>[6] @[PositDef.scala 364:22]
    node _T_21 = bits(io.in, 5, 5) @[PositDef.scala 372:25]
    inPadVec[5] <= _T_21 @[PositDef.scala 372:17]
    node _T_22 = bits(io.in, 4, 4) @[PositDef.scala 372:25]
    inPadVec[4] <= _T_22 @[PositDef.scala 372:17]
    node _T_23 = bits(io.in, 3, 3) @[PositDef.scala 372:25]
    inPadVec[3] <= _T_23 @[PositDef.scala 372:17]
    node _T_24 = bits(io.in, 2, 2) @[PositDef.scala 372:25]
    inPadVec[2] <= _T_24 @[PositDef.scala 372:17]
    node _T_25 = bits(io.in, 1, 1) @[PositDef.scala 372:25]
    inPadVec[1] <= _T_25 @[PositDef.scala 372:17]
    node _T_26 = bits(io.in, 0, 0) @[PositDef.scala 372:25]
    inPadVec[0] <= _T_26 @[PositDef.scala 372:17]
    node _T_27 = cat(inPadVec[2], inPadVec[1]) @[PositDef.scala 374:21]
    node _T_28 = cat(_T_27, inPadVec[0]) @[PositDef.scala 374:21]
    node _T_29 = cat(inPadVec[5], inPadVec[4]) @[PositDef.scala 374:21]
    node _T_30 = cat(_T_29, inPadVec[3]) @[PositDef.scala 374:21]
    node _T_31 = cat(_T_30, _T_28) @[PositDef.scala 374:21]
    inPad <= _T_31 @[PositDef.scala 374:9]
    inst tree of CountLeadingZerosTree_14 @[PositDef.scala 375:20]
    tree.clock <= clock
    tree.reset <= reset
    node _T_32 = bits(inPad, 5, 2) @[PositDef.scala 376:24]
    tree.io.left <= _T_32 @[PositDef.scala 376:16]
    node _T_33 = bits(io.in, 1, 0) @[PositDef.scala 377:25]
    tree.io.right <= _T_33 @[PositDef.scala 377:17]
    io.out <= tree.io.out @[PositDef.scala 378:10]
    
  module PositDecode_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {bits : UInt<8>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    wire remainderBits : UInt<7> @[PositDecode.scala 22:27]
    wire remainderXor : UInt<6> @[PositDecode.scala 27:26]
    wire remainderXorVec : UInt<1>[6] @[PositDecode.scala 28:29]
    wire cl0 : UInt<3> @[PositDecode.scala 31:17]
    wire regimePosOrZero : UInt<1> @[PositDecode.scala 35:29]
    wire isSpecial : UInt<1> @[PositDecode.scala 38:23]
    wire unsignedRegime : UInt<4> @[PositDecode.scala 41:28]
    wire regimeShiftMinus2 : UInt<3> @[PositDecode.scala 44:31]
    wire esAndFractionBits : UInt<5> @[PositDecode.scala 48:31]
    node _T_28 = bits(remainderBits, 6, 6) @[PositDecode.scala 54:44]
    node _T_29 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:63]
    node _T_30 = xor(_T_28, _T_29) @[PositDecode.scala 54:48]
    remainderXorVec[5] <= _T_30 @[PositDecode.scala 54:28]
    node _T_31 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:44]
    node _T_32 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:63]
    node _T_33 = xor(_T_31, _T_32) @[PositDecode.scala 54:48]
    remainderXorVec[4] <= _T_33 @[PositDecode.scala 54:28]
    node _T_34 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:44]
    node _T_35 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:63]
    node _T_36 = xor(_T_34, _T_35) @[PositDecode.scala 54:48]
    remainderXorVec[3] <= _T_36 @[PositDecode.scala 54:28]
    node _T_37 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:44]
    node _T_38 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:63]
    node _T_39 = xor(_T_37, _T_38) @[PositDecode.scala 54:48]
    remainderXorVec[2] <= _T_39 @[PositDecode.scala 54:28]
    node _T_40 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:44]
    node _T_41 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:63]
    node _T_42 = xor(_T_40, _T_41) @[PositDecode.scala 54:48]
    remainderXorVec[1] <= _T_42 @[PositDecode.scala 54:28]
    node _T_43 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:44]
    node _T_44 = bits(remainderBits, 0, 0) @[PositDecode.scala 54:63]
    node _T_45 = xor(_T_43, _T_44) @[PositDecode.scala 54:48]
    remainderXorVec[0] <= _T_45 @[PositDecode.scala 54:28]
    node _T_46 = cat(remainderXorVec[2], remainderXorVec[1]) @[PositDecode.scala 59:35]
    node _T_47 = cat(_T_46, remainderXorVec[0]) @[PositDecode.scala 59:35]
    node _T_48 = cat(remainderXorVec[5], remainderXorVec[4]) @[PositDecode.scala 59:35]
    node _T_49 = cat(_T_48, remainderXorVec[3]) @[PositDecode.scala 59:35]
    node _T_50 = cat(_T_49, _T_47) @[PositDecode.scala 59:35]
    remainderXor <= _T_50 @[PositDecode.scala 59:16]
    inst countingLeadingZeros of CountLeadingZeros_2 @[PositDecode.scala 64:36]
    countingLeadingZeros.clock <= clock
    countingLeadingZeros.reset <= reset
    countingLeadingZeros.io.in <= remainderXor @[PositDecode.scala 65:30]
    cl0 <= countingLeadingZeros.io.out @[PositDecode.scala 66:7]
    node _T_51 = bits(remainderBits, 4, 0) @[PositDecode.scala 69:37]
    node _T_52 = dshl(_T_51, regimeShiftMinus2) @[PositDecode.scala 69:72]
    esAndFractionBits <= _T_52 @[PositDecode.scala 69:21]
    node _T_53 = bits(io.in.bits, 6, 0) @[PositDecode.scala 72:30]
    remainderBits <= _T_53 @[PositDecode.scala 72:17]
    node _T_54 = bits(remainderBits, 6, 6) @[PositDecode.scala 74:35]
    regimePosOrZero <= _T_54 @[PositDecode.scala 74:19]
    node _T_56 = neq(remainderBits, UInt<1>("h00")) @[PositDecode.scala 76:31]
    node _T_58 = eq(_T_56, UInt<1>("h00")) @[PositDecode.scala 76:16]
    isSpecial <= _T_58 @[PositDecode.scala 76:13]
    wire cl0extended : UInt<4> @[PositDecode.scala 79:25]
    cl0extended <= cl0 @[PositDecode.scala 80:15]
    node _T_61 = eq(isSpecial, UInt<1>("h01")) @[PositDecode.scala 82:19]
    when _T_61 : @[PositDecode.scala 82:28]
      unsignedRegime <= UInt<4>("h00") @[PositDecode.scala 83:20]
      skip @[PositDecode.scala 82:28]
    else : @[PositDecode.scala 84:16]
      node _T_64 = eq(regimePosOrZero, UInt<1>("h01")) @[PositDecode.scala 85:28]
      node _T_65 = bits(_T_64, 0, 0) @[PositDecode.scala 85:43]
      when _T_65 : @[PositDecode.scala 85:47]
        unsignedRegime <= cl0extended @[PositDecode.scala 86:22]
        skip @[PositDecode.scala 85:47]
      else : @[PositDecode.scala 87:18]
        node _T_67 = not(cl0) @[PositDecode.scala 89:87]
        node _T_68 = add(UInt<3>("h06"), _T_67) @[PositDecode.scala 89:85]
        node _T_69 = tail(_T_68, 1) @[PositDecode.scala 89:85]
        unsignedRegime <= _T_69 @[PositDecode.scala 89:22]
        skip @[PositDecode.scala 87:18]
      skip @[PositDecode.scala 84:16]
    regimeShiftMinus2 <= cl0 @[PositDecode.scala 120:21]
    node _T_70 = bits(io.in.bits, 7, 7) @[PositDecode.scala 122:29]
    node _T_71 = bits(isSpecial, 0, 0) @[PositDecode.scala 122:60]
    node _T_72 = and(_T_70, _T_71) @[PositDecode.scala 122:41]
    io.out.isInf <= _T_72 @[PositDecode.scala 122:16]
    node _T_73 = bits(io.in.bits, 7, 7) @[PositDecode.scala 123:31]
    node _T_75 = eq(_T_73, UInt<1>("h00")) @[PositDecode.scala 123:20]
    node _T_76 = bits(isSpecial, 0, 0) @[PositDecode.scala 123:62]
    node _T_77 = and(_T_75, _T_76) @[PositDecode.scala 123:43]
    io.out.isZero <= _T_77 @[PositDecode.scala 123:17]
    node _T_79 = eq(isSpecial, UInt<1>("h00")) @[PositDecode.scala 124:18]
    node _T_80 = bits(io.in.bits, 7, 7) @[PositDecode.scala 124:42]
    node _T_81 = and(_T_79, _T_80) @[PositDecode.scala 124:29]
    io.out.sign <= _T_81 @[PositDecode.scala 124:15]
    wire _T_83 : UInt<1> @[PositDecode.scala 128:22]
    node _T_84 = bits(esAndFractionBits, 4, 4) @[PositDecode.scala 132:32]
    _T_83 <= _T_84 @[PositDecode.scala 132:12]
    node _T_85 = bits(esAndFractionBits, 3, 0) @[PositDecode.scala 134:41]
    io.out.fraction <= _T_85 @[PositDecode.scala 134:21]
    node _T_86 = cat(unsignedRegime, _T_83) @[Cat.scala 30:58]
    io.out.exponent <= _T_86 @[PositDecode.scala 135:21]
    
  module CountLeadingZerosTree_15 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_16 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_17 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<2>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<2> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<2> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[2] @[PositDef.scala 291:29]
    node _T_21 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_21 @[PositDef.scala 296:24]
    node _T_22 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = cat(rCountExtendVec[1], rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_23 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_15 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_24 = bits(io.left, 1, 1) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_24 @[PositDef.scala 307:23]
    node _T_25 = bits(io.left, 0, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_25 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_16 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_26 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_26 @[PositDef.scala 316:24]
    node _T_27 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_27 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_28 = bits(lCount, 1, 1) @[PositDef.scala 324:16]
    node _T_29 = bits(rCountExtend, 1, 1) @[PositDef.scala 324:55]
    node _T_30 = and(_T_28, _T_29) @[PositDef.scala 324:40]
    when _T_30 : @[PositDef.scala 324:80]
      node _T_33 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_33 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_34 = bits(lCount, 1, 1) @[PositDef.scala 326:24]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_36 : @[PositDef.scala 326:51]
        node _T_38 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_38 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_40 = bits(rCountExtend, 0, 0) @[PositDef.scala 329:43]
        node _T_41 = cat(UInt<2>("h01"), _T_40) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZerosTree_18 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_19 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<4>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<3> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<3> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[3] @[PositDef.scala 291:29]
    node _T_22 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_23 @[PositDef.scala 296:24]
    rCountExtendVec[2] <= UInt<1>("h00") @[PositDef.scala 300:24]
    node _T_25 = cat(rCountExtendVec[2], rCountExtendVec[1]) @[PositDef.scala 303:35]
    node _T_26 = cat(_T_25, rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_26 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_17 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_27 = bits(io.left, 3, 2) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_27 @[PositDef.scala 307:23]
    node _T_28 = bits(io.left, 1, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_28 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_18 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_29 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_29 @[PositDef.scala 316:24]
    node _T_30 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_30 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_31 = bits(lCount, 2, 2) @[PositDef.scala 324:16]
    node _T_32 = bits(rCountExtend, 2, 2) @[PositDef.scala 324:55]
    node _T_33 = and(_T_31, _T_32) @[PositDef.scala 324:40]
    when _T_33 : @[PositDef.scala 324:80]
      node _T_36 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_36 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_37 = bits(lCount, 2, 2) @[PositDef.scala 326:24]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_39 : @[PositDef.scala 326:51]
        node _T_41 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_43 = bits(rCountExtend, 1, 0) @[PositDef.scala 329:43]
        node _T_44 = cat(UInt<2>("h01"), _T_43) @[Cat.scala 30:58]
        io.out <= _T_44 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZeros_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<6>, out : UInt<3>}
    
    wire inPad : UInt<6> @[PositDef.scala 363:19]
    wire inPadVec : UInt<1>[6] @[PositDef.scala 364:22]
    node _T_21 = bits(io.in, 5, 5) @[PositDef.scala 372:25]
    inPadVec[5] <= _T_21 @[PositDef.scala 372:17]
    node _T_22 = bits(io.in, 4, 4) @[PositDef.scala 372:25]
    inPadVec[4] <= _T_22 @[PositDef.scala 372:17]
    node _T_23 = bits(io.in, 3, 3) @[PositDef.scala 372:25]
    inPadVec[3] <= _T_23 @[PositDef.scala 372:17]
    node _T_24 = bits(io.in, 2, 2) @[PositDef.scala 372:25]
    inPadVec[2] <= _T_24 @[PositDef.scala 372:17]
    node _T_25 = bits(io.in, 1, 1) @[PositDef.scala 372:25]
    inPadVec[1] <= _T_25 @[PositDef.scala 372:17]
    node _T_26 = bits(io.in, 0, 0) @[PositDef.scala 372:25]
    inPadVec[0] <= _T_26 @[PositDef.scala 372:17]
    node _T_27 = cat(inPadVec[2], inPadVec[1]) @[PositDef.scala 374:21]
    node _T_28 = cat(_T_27, inPadVec[0]) @[PositDef.scala 374:21]
    node _T_29 = cat(inPadVec[5], inPadVec[4]) @[PositDef.scala 374:21]
    node _T_30 = cat(_T_29, inPadVec[3]) @[PositDef.scala 374:21]
    node _T_31 = cat(_T_30, _T_28) @[PositDef.scala 374:21]
    inPad <= _T_31 @[PositDef.scala 374:9]
    inst tree of CountLeadingZerosTree_19 @[PositDef.scala 375:20]
    tree.clock <= clock
    tree.reset <= reset
    node _T_32 = bits(inPad, 5, 2) @[PositDef.scala 376:24]
    tree.io.left <= _T_32 @[PositDef.scala 376:16]
    node _T_33 = bits(io.in, 1, 0) @[PositDef.scala 377:25]
    tree.io.right <= _T_33 @[PositDef.scala 377:17]
    io.out <= tree.io.out @[PositDef.scala 378:10]
    
  module CountLeadingZerosTree_20 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_21 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_22 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<2>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<2> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<2> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[2] @[PositDef.scala 291:29]
    node _T_21 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_21 @[PositDef.scala 296:24]
    node _T_22 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = cat(rCountExtendVec[1], rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_23 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_20 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_24 = bits(io.left, 1, 1) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_24 @[PositDef.scala 307:23]
    node _T_25 = bits(io.left, 0, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_25 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_21 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_26 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_26 @[PositDef.scala 316:24]
    node _T_27 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_27 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_28 = bits(lCount, 1, 1) @[PositDef.scala 324:16]
    node _T_29 = bits(rCountExtend, 1, 1) @[PositDef.scala 324:55]
    node _T_30 = and(_T_28, _T_29) @[PositDef.scala 324:40]
    when _T_30 : @[PositDef.scala 324:80]
      node _T_33 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_33 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_34 = bits(lCount, 1, 1) @[PositDef.scala 326:24]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_36 : @[PositDef.scala 326:51]
        node _T_38 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_38 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_40 = bits(rCountExtend, 0, 0) @[PositDef.scala 329:43]
        node _T_41 = cat(UInt<2>("h01"), _T_40) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZerosTree_23 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_24 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<4>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<3> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<3> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[3] @[PositDef.scala 291:29]
    node _T_22 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_23 @[PositDef.scala 296:24]
    rCountExtendVec[2] <= UInt<1>("h00") @[PositDef.scala 300:24]
    node _T_25 = cat(rCountExtendVec[2], rCountExtendVec[1]) @[PositDef.scala 303:35]
    node _T_26 = cat(_T_25, rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_26 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_22 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_27 = bits(io.left, 3, 2) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_27 @[PositDef.scala 307:23]
    node _T_28 = bits(io.left, 1, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_28 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_23 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_29 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_29 @[PositDef.scala 316:24]
    node _T_30 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_30 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_31 = bits(lCount, 2, 2) @[PositDef.scala 324:16]
    node _T_32 = bits(rCountExtend, 2, 2) @[PositDef.scala 324:55]
    node _T_33 = and(_T_31, _T_32) @[PositDef.scala 324:40]
    when _T_33 : @[PositDef.scala 324:80]
      node _T_36 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_36 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_37 = bits(lCount, 2, 2) @[PositDef.scala 326:24]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_39 : @[PositDef.scala 326:51]
        node _T_41 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_43 = bits(rCountExtend, 1, 0) @[PositDef.scala 329:43]
        node _T_44 = cat(UInt<2>("h01"), _T_43) @[Cat.scala 30:58]
        io.out <= _T_44 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZeros_4 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<6>, out : UInt<3>}
    
    wire inPad : UInt<6> @[PositDef.scala 363:19]
    wire inPadVec : UInt<1>[6] @[PositDef.scala 364:22]
    node _T_21 = bits(io.in, 5, 5) @[PositDef.scala 372:25]
    inPadVec[5] <= _T_21 @[PositDef.scala 372:17]
    node _T_22 = bits(io.in, 4, 4) @[PositDef.scala 372:25]
    inPadVec[4] <= _T_22 @[PositDef.scala 372:17]
    node _T_23 = bits(io.in, 3, 3) @[PositDef.scala 372:25]
    inPadVec[3] <= _T_23 @[PositDef.scala 372:17]
    node _T_24 = bits(io.in, 2, 2) @[PositDef.scala 372:25]
    inPadVec[2] <= _T_24 @[PositDef.scala 372:17]
    node _T_25 = bits(io.in, 1, 1) @[PositDef.scala 372:25]
    inPadVec[1] <= _T_25 @[PositDef.scala 372:17]
    node _T_26 = bits(io.in, 0, 0) @[PositDef.scala 372:25]
    inPadVec[0] <= _T_26 @[PositDef.scala 372:17]
    node _T_27 = cat(inPadVec[2], inPadVec[1]) @[PositDef.scala 374:21]
    node _T_28 = cat(_T_27, inPadVec[0]) @[PositDef.scala 374:21]
    node _T_29 = cat(inPadVec[5], inPadVec[4]) @[PositDef.scala 374:21]
    node _T_30 = cat(_T_29, inPadVec[3]) @[PositDef.scala 374:21]
    node _T_31 = cat(_T_30, _T_28) @[PositDef.scala 374:21]
    inPad <= _T_31 @[PositDef.scala 374:9]
    inst tree of CountLeadingZerosTree_24 @[PositDef.scala 375:20]
    tree.clock <= clock
    tree.reset <= reset
    node _T_32 = bits(inPad, 5, 2) @[PositDef.scala 376:24]
    tree.io.left <= _T_32 @[PositDef.scala 376:16]
    node _T_33 = bits(io.in, 1, 0) @[PositDef.scala 377:25]
    tree.io.right <= _T_33 @[PositDef.scala 377:17]
    io.out <= tree.io.out @[PositDef.scala 378:10]
    
  module PositDecode_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {bits : UInt<8>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    wire remainderBits : UInt<7> @[PositDecode.scala 22:27]
    wire remainderXor : UInt<6> @[PositDecode.scala 27:26]
    wire remainderXorVec : UInt<1>[6] @[PositDecode.scala 28:29]
    wire cl0 : UInt<3> @[PositDecode.scala 31:17]
    wire regimePosOrZero : UInt<1> @[PositDecode.scala 35:29]
    wire isSpecial : UInt<1> @[PositDecode.scala 38:23]
    wire unsignedRegime : UInt<4> @[PositDecode.scala 41:28]
    wire regimeShiftMinus2 : UInt<3> @[PositDecode.scala 44:31]
    wire esAndFractionBits : UInt<5> @[PositDecode.scala 48:31]
    node _T_28 = bits(remainderBits, 6, 6) @[PositDecode.scala 54:44]
    node _T_29 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:63]
    node _T_30 = xor(_T_28, _T_29) @[PositDecode.scala 54:48]
    remainderXorVec[5] <= _T_30 @[PositDecode.scala 54:28]
    node _T_31 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:44]
    node _T_32 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:63]
    node _T_33 = xor(_T_31, _T_32) @[PositDecode.scala 54:48]
    remainderXorVec[4] <= _T_33 @[PositDecode.scala 54:28]
    node _T_34 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:44]
    node _T_35 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:63]
    node _T_36 = xor(_T_34, _T_35) @[PositDecode.scala 54:48]
    remainderXorVec[3] <= _T_36 @[PositDecode.scala 54:28]
    node _T_37 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:44]
    node _T_38 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:63]
    node _T_39 = xor(_T_37, _T_38) @[PositDecode.scala 54:48]
    remainderXorVec[2] <= _T_39 @[PositDecode.scala 54:28]
    node _T_40 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:44]
    node _T_41 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:63]
    node _T_42 = xor(_T_40, _T_41) @[PositDecode.scala 54:48]
    remainderXorVec[1] <= _T_42 @[PositDecode.scala 54:28]
    node _T_43 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:44]
    node _T_44 = bits(remainderBits, 0, 0) @[PositDecode.scala 54:63]
    node _T_45 = xor(_T_43, _T_44) @[PositDecode.scala 54:48]
    remainderXorVec[0] <= _T_45 @[PositDecode.scala 54:28]
    node _T_46 = cat(remainderXorVec[2], remainderXorVec[1]) @[PositDecode.scala 59:35]
    node _T_47 = cat(_T_46, remainderXorVec[0]) @[PositDecode.scala 59:35]
    node _T_48 = cat(remainderXorVec[5], remainderXorVec[4]) @[PositDecode.scala 59:35]
    node _T_49 = cat(_T_48, remainderXorVec[3]) @[PositDecode.scala 59:35]
    node _T_50 = cat(_T_49, _T_47) @[PositDecode.scala 59:35]
    remainderXor <= _T_50 @[PositDecode.scala 59:16]
    inst countingLeadingZeros of CountLeadingZeros_4 @[PositDecode.scala 64:36]
    countingLeadingZeros.clock <= clock
    countingLeadingZeros.reset <= reset
    countingLeadingZeros.io.in <= remainderXor @[PositDecode.scala 65:30]
    cl0 <= countingLeadingZeros.io.out @[PositDecode.scala 66:7]
    node _T_51 = bits(remainderBits, 4, 0) @[PositDecode.scala 69:37]
    node _T_52 = dshl(_T_51, regimeShiftMinus2) @[PositDecode.scala 69:72]
    esAndFractionBits <= _T_52 @[PositDecode.scala 69:21]
    node _T_53 = bits(io.in.bits, 6, 0) @[PositDecode.scala 72:30]
    remainderBits <= _T_53 @[PositDecode.scala 72:17]
    node _T_54 = bits(remainderBits, 6, 6) @[PositDecode.scala 74:35]
    regimePosOrZero <= _T_54 @[PositDecode.scala 74:19]
    node _T_56 = neq(remainderBits, UInt<1>("h00")) @[PositDecode.scala 76:31]
    node _T_58 = eq(_T_56, UInt<1>("h00")) @[PositDecode.scala 76:16]
    isSpecial <= _T_58 @[PositDecode.scala 76:13]
    wire cl0extended : UInt<4> @[PositDecode.scala 79:25]
    cl0extended <= cl0 @[PositDecode.scala 80:15]
    node _T_61 = eq(isSpecial, UInt<1>("h01")) @[PositDecode.scala 82:19]
    when _T_61 : @[PositDecode.scala 82:28]
      unsignedRegime <= UInt<4>("h00") @[PositDecode.scala 83:20]
      skip @[PositDecode.scala 82:28]
    else : @[PositDecode.scala 84:16]
      node _T_64 = eq(regimePosOrZero, UInt<1>("h01")) @[PositDecode.scala 85:28]
      node _T_65 = bits(_T_64, 0, 0) @[PositDecode.scala 85:43]
      when _T_65 : @[PositDecode.scala 85:47]
        unsignedRegime <= cl0extended @[PositDecode.scala 86:22]
        skip @[PositDecode.scala 85:47]
      else : @[PositDecode.scala 87:18]
        node _T_67 = not(cl0) @[PositDecode.scala 89:87]
        node _T_68 = add(UInt<3>("h06"), _T_67) @[PositDecode.scala 89:85]
        node _T_69 = tail(_T_68, 1) @[PositDecode.scala 89:85]
        unsignedRegime <= _T_69 @[PositDecode.scala 89:22]
        skip @[PositDecode.scala 87:18]
      skip @[PositDecode.scala 84:16]
    regimeShiftMinus2 <= cl0 @[PositDecode.scala 120:21]
    node _T_70 = bits(io.in.bits, 7, 7) @[PositDecode.scala 122:29]
    node _T_71 = bits(isSpecial, 0, 0) @[PositDecode.scala 122:60]
    node _T_72 = and(_T_70, _T_71) @[PositDecode.scala 122:41]
    io.out.isInf <= _T_72 @[PositDecode.scala 122:16]
    node _T_73 = bits(io.in.bits, 7, 7) @[PositDecode.scala 123:31]
    node _T_75 = eq(_T_73, UInt<1>("h00")) @[PositDecode.scala 123:20]
    node _T_76 = bits(isSpecial, 0, 0) @[PositDecode.scala 123:62]
    node _T_77 = and(_T_75, _T_76) @[PositDecode.scala 123:43]
    io.out.isZero <= _T_77 @[PositDecode.scala 123:17]
    node _T_79 = eq(isSpecial, UInt<1>("h00")) @[PositDecode.scala 124:18]
    node _T_80 = bits(io.in.bits, 7, 7) @[PositDecode.scala 124:42]
    node _T_81 = and(_T_79, _T_80) @[PositDecode.scala 124:29]
    io.out.sign <= _T_81 @[PositDecode.scala 124:15]
    wire _T_83 : UInt<1> @[PositDecode.scala 128:22]
    node _T_84 = bits(esAndFractionBits, 4, 4) @[PositDecode.scala 132:32]
    _T_83 <= _T_84 @[PositDecode.scala 132:12]
    node _T_85 = bits(esAndFractionBits, 3, 0) @[PositDecode.scala 134:41]
    io.out.fraction <= _T_85 @[PositDecode.scala 134:21]
    node _T_86 = cat(unsignedRegime, _T_83) @[Cat.scala 30:58]
    io.out.exponent <= _T_86 @[PositDecode.scala 135:21]
    
  module CountLeadingZerosTree_25 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_26 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_27 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<2>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<2> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<2> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[2] @[PositDef.scala 291:29]
    node _T_21 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_21 @[PositDef.scala 296:24]
    node _T_22 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = cat(rCountExtendVec[1], rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_23 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_25 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_24 = bits(io.left, 1, 1) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_24 @[PositDef.scala 307:23]
    node _T_25 = bits(io.left, 0, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_25 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_26 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_26 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_26 @[PositDef.scala 316:24]
    node _T_27 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_27 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_28 = bits(lCount, 1, 1) @[PositDef.scala 324:16]
    node _T_29 = bits(rCountExtend, 1, 1) @[PositDef.scala 324:55]
    node _T_30 = and(_T_28, _T_29) @[PositDef.scala 324:40]
    when _T_30 : @[PositDef.scala 324:80]
      node _T_33 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_33 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_34 = bits(lCount, 1, 1) @[PositDef.scala 326:24]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_36 : @[PositDef.scala 326:51]
        node _T_38 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_38 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_40 = bits(rCountExtend, 0, 0) @[PositDef.scala 329:43]
        node _T_41 = cat(UInt<2>("h01"), _T_40) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZerosTree_28 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<1>, flip right : UInt<1>, out : UInt<2>}
    
    wire lCount : UInt<1> @[PositDef.scala 287:20]
    wire rCount : UInt<1> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<1> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[1] @[PositDef.scala 291:29]
    node _T_20 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_20 @[PositDef.scala 296:24]
    rCountExtend <= rCountExtendVec[0] @[PositDef.scala 303:16]
    node _T_21 = bits(io.left, 0, 0) @[PositDef.scala 311:23]
    node _T_22 = not(_T_21) @[PositDef.scala 311:15]
    lCount <= _T_22 @[PositDef.scala 311:12]
    node _T_23 = bits(io.right, 0, 0) @[PositDef.scala 320:24]
    node _T_24 = not(_T_23) @[PositDef.scala 320:15]
    rCount <= _T_24 @[PositDef.scala 320:12]
    node _T_25 = bits(lCount, 0, 0) @[PositDef.scala 337:16]
    node _T_26 = bits(rCountExtend, 0, 0) @[PositDef.scala 337:55]
    node _T_27 = and(_T_25, _T_26) @[PositDef.scala 337:40]
    when _T_27 : @[PositDef.scala 337:80]
      node _T_30 = cat(UInt<1>("h01"), UInt<1>("h00")) @[Cat.scala 30:58]
      io.out <= _T_30 @[PositDef.scala 338:14]
      skip @[PositDef.scala 337:80]
    else : @[PositDef.scala 339:51]
      node _T_31 = bits(lCount, 0, 0) @[PositDef.scala 339:24]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[PositDef.scala 339:17]
      when _T_33 : @[PositDef.scala 339:51]
        node _T_35 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_35 @[PositDef.scala 340:14]
        skip @[PositDef.scala 339:51]
      else : @[PositDef.scala 341:18]
        io.out <= UInt<2>("h01") @[PositDef.scala 342:14]
        skip @[PositDef.scala 341:18]
    
  module CountLeadingZerosTree_29 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip left : UInt<4>, flip right : UInt<2>, out : UInt<3>}
    
    wire lCount : UInt<3> @[PositDef.scala 287:20]
    wire rCount : UInt<2> @[PositDef.scala 288:20]
    wire rCountExtend : UInt<3> @[PositDef.scala 290:26]
    wire rCountExtendVec : UInt<1>[3] @[PositDef.scala 291:29]
    node _T_22 = bits(rCount, 1, 1) @[PositDef.scala 296:33]
    rCountExtendVec[1] <= _T_22 @[PositDef.scala 296:24]
    node _T_23 = bits(rCount, 0, 0) @[PositDef.scala 296:33]
    rCountExtendVec[0] <= _T_23 @[PositDef.scala 296:24]
    rCountExtendVec[2] <= UInt<1>("h00") @[PositDef.scala 300:24]
    node _T_25 = cat(rCountExtendVec[2], rCountExtendVec[1]) @[PositDef.scala 303:35]
    node _T_26 = cat(_T_25, rCountExtendVec[0]) @[PositDef.scala 303:35]
    rCountExtend <= _T_26 @[PositDef.scala 303:16]
    inst CountLeadingZerosTree of CountLeadingZerosTree_27 @[PositDef.scala 306:27]
    CountLeadingZerosTree.clock <= clock
    CountLeadingZerosTree.reset <= reset
    node _T_27 = bits(io.left, 3, 2) @[PositDef.scala 307:33]
    CountLeadingZerosTree.io.left <= _T_27 @[PositDef.scala 307:23]
    node _T_28 = bits(io.left, 1, 0) @[PositDef.scala 308:34]
    CountLeadingZerosTree.io.right <= _T_28 @[PositDef.scala 308:24]
    lCount <= CountLeadingZerosTree.io.out @[PositDef.scala 309:12]
    inst CountLeadingZerosTree_1 of CountLeadingZerosTree_28 @[PositDef.scala 315:28]
    CountLeadingZerosTree_1.clock <= clock
    CountLeadingZerosTree_1.reset <= reset
    node _T_29 = bits(io.right, 1, 1) @[PositDef.scala 316:35]
    CountLeadingZerosTree_1.io.left <= _T_29 @[PositDef.scala 316:24]
    node _T_30 = bits(io.right, 0, 0) @[PositDef.scala 317:36]
    CountLeadingZerosTree_1.io.right <= _T_30 @[PositDef.scala 317:25]
    rCount <= CountLeadingZerosTree_1.io.out @[PositDef.scala 318:12]
    node _T_31 = bits(lCount, 2, 2) @[PositDef.scala 324:16]
    node _T_32 = bits(rCountExtend, 2, 2) @[PositDef.scala 324:55]
    node _T_33 = and(_T_31, _T_32) @[PositDef.scala 324:40]
    when _T_33 : @[PositDef.scala 324:80]
      node _T_36 = cat(UInt<1>("h01"), UInt<2>("h00")) @[Cat.scala 30:58]
      io.out <= _T_36 @[PositDef.scala 325:14]
      skip @[PositDef.scala 324:80]
    else : @[PositDef.scala 326:51]
      node _T_37 = bits(lCount, 2, 2) @[PositDef.scala 326:24]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[PositDef.scala 326:17]
      when _T_39 : @[PositDef.scala 326:51]
        node _T_41 = cat(UInt<1>("h00"), lCount) @[Cat.scala 30:58]
        io.out <= _T_41 @[PositDef.scala 327:14]
        skip @[PositDef.scala 326:51]
      else : @[PositDef.scala 328:18]
        node _T_43 = bits(rCountExtend, 1, 0) @[PositDef.scala 329:43]
        node _T_44 = cat(UInt<2>("h01"), _T_43) @[Cat.scala 30:58]
        io.out <= _T_44 @[PositDef.scala 329:14]
        skip @[PositDef.scala 328:18]
    
  module CountLeadingZeros_5 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<6>, out : UInt<3>}
    
    wire inPad : UInt<6> @[PositDef.scala 363:19]
    wire inPadVec : UInt<1>[6] @[PositDef.scala 364:22]
    node _T_21 = bits(io.in, 5, 5) @[PositDef.scala 372:25]
    inPadVec[5] <= _T_21 @[PositDef.scala 372:17]
    node _T_22 = bits(io.in, 4, 4) @[PositDef.scala 372:25]
    inPadVec[4] <= _T_22 @[PositDef.scala 372:17]
    node _T_23 = bits(io.in, 3, 3) @[PositDef.scala 372:25]
    inPadVec[3] <= _T_23 @[PositDef.scala 372:17]
    node _T_24 = bits(io.in, 2, 2) @[PositDef.scala 372:25]
    inPadVec[2] <= _T_24 @[PositDef.scala 372:17]
    node _T_25 = bits(io.in, 1, 1) @[PositDef.scala 372:25]
    inPadVec[1] <= _T_25 @[PositDef.scala 372:17]
    node _T_26 = bits(io.in, 0, 0) @[PositDef.scala 372:25]
    inPadVec[0] <= _T_26 @[PositDef.scala 372:17]
    node _T_27 = cat(inPadVec[2], inPadVec[1]) @[PositDef.scala 374:21]
    node _T_28 = cat(_T_27, inPadVec[0]) @[PositDef.scala 374:21]
    node _T_29 = cat(inPadVec[5], inPadVec[4]) @[PositDef.scala 374:21]
    node _T_30 = cat(_T_29, inPadVec[3]) @[PositDef.scala 374:21]
    node _T_31 = cat(_T_30, _T_28) @[PositDef.scala 374:21]
    inPad <= _T_31 @[PositDef.scala 374:9]
    inst tree of CountLeadingZerosTree_29 @[PositDef.scala 375:20]
    tree.clock <= clock
    tree.reset <= reset
    node _T_32 = bits(inPad, 5, 2) @[PositDef.scala 376:24]
    tree.io.left <= _T_32 @[PositDef.scala 376:16]
    node _T_33 = bits(io.in, 1, 0) @[PositDef.scala 377:25]
    tree.io.right <= _T_33 @[PositDef.scala 377:17]
    io.out <= tree.io.out @[PositDef.scala 378:10]
    
  module PositDecode_4 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {bits : UInt<8>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    wire remainderBits : UInt<7> @[PositDecode.scala 22:27]
    wire remainderXor : UInt<6> @[PositDecode.scala 27:26]
    wire remainderXorVec : UInt<1>[6] @[PositDecode.scala 28:29]
    wire cl0 : UInt<3> @[PositDecode.scala 31:17]
    wire regimePosOrZero : UInt<1> @[PositDecode.scala 35:29]
    wire isSpecial : UInt<1> @[PositDecode.scala 38:23]
    wire unsignedRegime : UInt<4> @[PositDecode.scala 41:28]
    wire regimeShiftMinus2 : UInt<3> @[PositDecode.scala 44:31]
    wire esAndFractionBits : UInt<5> @[PositDecode.scala 48:31]
    node _T_28 = bits(remainderBits, 6, 6) @[PositDecode.scala 54:44]
    node _T_29 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:63]
    node _T_30 = xor(_T_28, _T_29) @[PositDecode.scala 54:48]
    remainderXorVec[5] <= _T_30 @[PositDecode.scala 54:28]
    node _T_31 = bits(remainderBits, 5, 5) @[PositDecode.scala 54:44]
    node _T_32 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:63]
    node _T_33 = xor(_T_31, _T_32) @[PositDecode.scala 54:48]
    remainderXorVec[4] <= _T_33 @[PositDecode.scala 54:28]
    node _T_34 = bits(remainderBits, 4, 4) @[PositDecode.scala 54:44]
    node _T_35 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:63]
    node _T_36 = xor(_T_34, _T_35) @[PositDecode.scala 54:48]
    remainderXorVec[3] <= _T_36 @[PositDecode.scala 54:28]
    node _T_37 = bits(remainderBits, 3, 3) @[PositDecode.scala 54:44]
    node _T_38 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:63]
    node _T_39 = xor(_T_37, _T_38) @[PositDecode.scala 54:48]
    remainderXorVec[2] <= _T_39 @[PositDecode.scala 54:28]
    node _T_40 = bits(remainderBits, 2, 2) @[PositDecode.scala 54:44]
    node _T_41 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:63]
    node _T_42 = xor(_T_40, _T_41) @[PositDecode.scala 54:48]
    remainderXorVec[1] <= _T_42 @[PositDecode.scala 54:28]
    node _T_43 = bits(remainderBits, 1, 1) @[PositDecode.scala 54:44]
    node _T_44 = bits(remainderBits, 0, 0) @[PositDecode.scala 54:63]
    node _T_45 = xor(_T_43, _T_44) @[PositDecode.scala 54:48]
    remainderXorVec[0] <= _T_45 @[PositDecode.scala 54:28]
    node _T_46 = cat(remainderXorVec[2], remainderXorVec[1]) @[PositDecode.scala 59:35]
    node _T_47 = cat(_T_46, remainderXorVec[0]) @[PositDecode.scala 59:35]
    node _T_48 = cat(remainderXorVec[5], remainderXorVec[4]) @[PositDecode.scala 59:35]
    node _T_49 = cat(_T_48, remainderXorVec[3]) @[PositDecode.scala 59:35]
    node _T_50 = cat(_T_49, _T_47) @[PositDecode.scala 59:35]
    remainderXor <= _T_50 @[PositDecode.scala 59:16]
    inst countingLeadingZeros of CountLeadingZeros_5 @[PositDecode.scala 64:36]
    countingLeadingZeros.clock <= clock
    countingLeadingZeros.reset <= reset
    countingLeadingZeros.io.in <= remainderXor @[PositDecode.scala 65:30]
    cl0 <= countingLeadingZeros.io.out @[PositDecode.scala 66:7]
    node _T_51 = bits(remainderBits, 4, 0) @[PositDecode.scala 69:37]
    node _T_52 = dshl(_T_51, regimeShiftMinus2) @[PositDecode.scala 69:72]
    esAndFractionBits <= _T_52 @[PositDecode.scala 69:21]
    node _T_53 = bits(io.in.bits, 6, 0) @[PositDecode.scala 72:30]
    remainderBits <= _T_53 @[PositDecode.scala 72:17]
    node _T_54 = bits(remainderBits, 6, 6) @[PositDecode.scala 74:35]
    regimePosOrZero <= _T_54 @[PositDecode.scala 74:19]
    node _T_56 = neq(remainderBits, UInt<1>("h00")) @[PositDecode.scala 76:31]
    node _T_58 = eq(_T_56, UInt<1>("h00")) @[PositDecode.scala 76:16]
    isSpecial <= _T_58 @[PositDecode.scala 76:13]
    wire cl0extended : UInt<4> @[PositDecode.scala 79:25]
    cl0extended <= cl0 @[PositDecode.scala 80:15]
    node _T_61 = eq(isSpecial, UInt<1>("h01")) @[PositDecode.scala 82:19]
    when _T_61 : @[PositDecode.scala 82:28]
      unsignedRegime <= UInt<4>("h00") @[PositDecode.scala 83:20]
      skip @[PositDecode.scala 82:28]
    else : @[PositDecode.scala 84:16]
      node _T_64 = eq(regimePosOrZero, UInt<1>("h01")) @[PositDecode.scala 85:28]
      node _T_65 = bits(_T_64, 0, 0) @[PositDecode.scala 85:43]
      when _T_65 : @[PositDecode.scala 85:47]
        unsignedRegime <= cl0extended @[PositDecode.scala 86:22]
        skip @[PositDecode.scala 85:47]
      else : @[PositDecode.scala 87:18]
        node _T_67 = not(cl0) @[PositDecode.scala 89:87]
        node _T_68 = add(UInt<3>("h06"), _T_67) @[PositDecode.scala 89:85]
        node _T_69 = tail(_T_68, 1) @[PositDecode.scala 89:85]
        unsignedRegime <= _T_69 @[PositDecode.scala 89:22]
        skip @[PositDecode.scala 87:18]
      skip @[PositDecode.scala 84:16]
    regimeShiftMinus2 <= cl0 @[PositDecode.scala 120:21]
    node _T_70 = bits(io.in.bits, 7, 7) @[PositDecode.scala 122:29]
    node _T_71 = bits(isSpecial, 0, 0) @[PositDecode.scala 122:60]
    node _T_72 = and(_T_70, _T_71) @[PositDecode.scala 122:41]
    io.out.isInf <= _T_72 @[PositDecode.scala 122:16]
    node _T_73 = bits(io.in.bits, 7, 7) @[PositDecode.scala 123:31]
    node _T_75 = eq(_T_73, UInt<1>("h00")) @[PositDecode.scala 123:20]
    node _T_76 = bits(isSpecial, 0, 0) @[PositDecode.scala 123:62]
    node _T_77 = and(_T_75, _T_76) @[PositDecode.scala 123:43]
    io.out.isZero <= _T_77 @[PositDecode.scala 123:17]
    node _T_79 = eq(isSpecial, UInt<1>("h00")) @[PositDecode.scala 124:18]
    node _T_80 = bits(io.in.bits, 7, 7) @[PositDecode.scala 124:42]
    node _T_81 = and(_T_79, _T_80) @[PositDecode.scala 124:29]
    io.out.sign <= _T_81 @[PositDecode.scala 124:15]
    wire _T_83 : UInt<1> @[PositDecode.scala 128:22]
    node _T_84 = bits(esAndFractionBits, 4, 4) @[PositDecode.scala 132:32]
    _T_83 <= _T_84 @[PositDecode.scala 132:12]
    node _T_85 = bits(esAndFractionBits, 3, 0) @[PositDecode.scala 134:41]
    io.out.fraction <= _T_85 @[PositDecode.scala 134:21]
    node _T_86 = cat(unsignedRegime, _T_83) @[Cat.scala 30:58]
    io.out.exponent <= _T_86 @[PositDecode.scala 135:21]
    
  module ZeroPadRight_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<10>, out : UInt<3>}
    
    node _T_9 = bits(io.in, 9, 6) @[PositDef.scala 139:20]
    io.out <= _T_9 @[PositDef.scala 139:12]
    
  module ShiftRightSticky_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<10>, flip shift : UInt<4>, out : UInt<3>, sticky : UInt<1>, stickyAnd : UInt<1>}
    
    wire valVector : UInt<3>[3] @[PositDef.scala 168:23]
    wire valVectorOfVecs : UInt<1>[3][3] @[PositDef.scala 169:29]
    node _T_109 = cat(valVectorOfVecs[2][2], valVectorOfVecs[2][1]) @[PositDef.scala 171:40]
    node _T_110 = cat(_T_109, valVectorOfVecs[2][0]) @[PositDef.scala 171:40]
    valVector[2] <= _T_110 @[PositDef.scala 171:18]
    node _T_111 = cat(valVectorOfVecs[1][2], valVectorOfVecs[1][1]) @[PositDef.scala 171:40]
    node _T_112 = cat(_T_111, valVectorOfVecs[1][0]) @[PositDef.scala 171:40]
    valVector[1] <= _T_112 @[PositDef.scala 171:18]
    node _T_113 = cat(valVectorOfVecs[0][2], valVectorOfVecs[0][1]) @[PositDef.scala 171:40]
    node _T_114 = cat(_T_113, valVectorOfVecs[0][0]) @[PositDef.scala 171:40]
    valVector[0] <= _T_114 @[PositDef.scala 171:18]
    wire valSticky : UInt<3> @[PositDef.scala 175:23]
    wire valStickyVec : UInt<1>[3] @[PositDef.scala 176:26]
    node _T_124 = cat(valStickyVec[2], valStickyVec[1]) @[PositDef.scala 177:29]
    node _T_125 = cat(_T_124, valStickyVec[0]) @[PositDef.scala 177:29]
    valSticky <= _T_125 @[PositDef.scala 177:13]
    wire valStickyAnd : UInt<3> @[PositDef.scala 179:26]
    wire valStickyAndVec : UInt<1>[3] @[PositDef.scala 180:29]
    node _T_135 = cat(valStickyAndVec[2], valStickyAndVec[1]) @[PositDef.scala 181:35]
    node _T_136 = cat(_T_135, valStickyAndVec[0]) @[PositDef.scala 181:35]
    valStickyAnd <= _T_136 @[PositDef.scala 181:16]
    wire maxShift : UInt<1> @[PositDef.scala 183:22]
    inst padding of ZeroPadRight_2 @[PositDef.scala 185:23]
    padding.clock <= clock
    padding.reset <= reset
    padding.io.in <= io.in @[PositDef.scala 186:17]
    node _T_138 = bits(padding.io.out, 0, 0) @[PositDef.scala 189:44]
    valVectorOfVecs[0][0] <= _T_138 @[PositDef.scala 189:27]
    node _T_139 = bits(padding.io.out, 1, 1) @[PositDef.scala 189:44]
    valVectorOfVecs[0][1] <= _T_139 @[PositDef.scala 189:27]
    node _T_140 = bits(padding.io.out, 2, 2) @[PositDef.scala 189:44]
    valVectorOfVecs[0][2] <= _T_140 @[PositDef.scala 189:27]
    node _T_141 = bits(io.in, 6, 0) @[PositDef.scala 196:29]
    node _T_143 = neq(_T_141, UInt<1>("h00")) @[PositDef.scala 196:59]
    valStickyVec[0] <= _T_143 @[PositDef.scala 196:21]
    node _T_144 = bits(io.in, 6, 0) @[PositDef.scala 197:32]
    node _T_145 = not(_T_144) @[PositDef.scala 197:62]
    node _T_147 = eq(_T_145, UInt<1>("h00")) @[PositDef.scala 197:62]
    valStickyAndVec[0] <= _T_147 @[PositDef.scala 197:24]
    node _T_148 = bits(io.shift, 0, 0) @[PositDef.scala 209:20]
    node _T_150 = bits(valVector[0], 0, 0) @[PositDef.scala 212:52]
    valVectorOfVecs[1][0] <= _T_150 @[PositDef.scala 212:33]
    node _T_151 = bits(io.shift, 0, 0) @[PositDef.scala 209:20]
    node _T_153 = bits(valVector[0], 1, 1) @[PositDef.scala 212:52]
    valVectorOfVecs[1][1] <= _T_153 @[PositDef.scala 212:33]
    node _T_154 = bits(io.shift, 0, 0) @[PositDef.scala 203:20]
    node _T_156 = bits(valVector[0], 2, 2) @[PositDef.scala 206:52]
    valVectorOfVecs[1][2] <= _T_156 @[PositDef.scala 206:33]
    wire _T_158 : UInt<1> @[PositDef.scala 216:28]
    wire _T_160 : UInt<1> @[PositDef.scala 217:31]
    node _T_161 = bits(io.shift, 0, 0) @[PositDef.scala 218:16]
    _T_158 <= UInt<1>("h00") @[PositDef.scala 223:20]
    _T_160 <= UInt<1>("h01") @[PositDef.scala 224:23]
    node _T_165 = or(valStickyVec[0], _T_158) @[PositDef.scala 226:44]
    valStickyVec[1] <= _T_165 @[PositDef.scala 226:21]
    node _T_166 = and(valStickyAndVec[0], _T_160) @[PositDef.scala 227:48]
    valStickyAndVec[1] <= _T_166 @[PositDef.scala 227:24]
    node _T_167 = bits(io.shift, 1, 1) @[PositDef.scala 209:20]
    node _T_169 = bits(valVector[1], 0, 0) @[PositDef.scala 212:52]
    valVectorOfVecs[2][0] <= _T_169 @[PositDef.scala 212:33]
    node _T_170 = bits(io.shift, 1, 1) @[PositDef.scala 203:20]
    node _T_172 = bits(valVector[1], 1, 1) @[PositDef.scala 206:52]
    valVectorOfVecs[2][1] <= _T_172 @[PositDef.scala 206:33]
    node _T_173 = bits(io.shift, 1, 1) @[PositDef.scala 203:20]
    node _T_175 = bits(valVector[1], 2, 2) @[PositDef.scala 206:52]
    valVectorOfVecs[2][2] <= _T_175 @[PositDef.scala 206:33]
    wire _T_177 : UInt<1> @[PositDef.scala 216:28]
    wire _T_179 : UInt<1> @[PositDef.scala 217:31]
    node _T_180 = bits(io.shift, 1, 1) @[PositDef.scala 218:16]
    _T_177 <= UInt<1>("h00") @[PositDef.scala 223:20]
    _T_179 <= UInt<1>("h01") @[PositDef.scala 224:23]
    node _T_184 = or(valStickyVec[1], _T_177) @[PositDef.scala 226:44]
    valStickyVec[2] <= _T_184 @[PositDef.scala 226:21]
    node _T_185 = and(valStickyAndVec[1], _T_179) @[PositDef.scala 227:48]
    valStickyAndVec[2] <= _T_185 @[PositDef.scala 227:24]
    node _T_187 = geq(io.shift, UInt<2>("h03")) @[PositDef.scala 251:27]
    maxShift <= _T_187 @[PositDef.scala 251:14]
    io.out <= valVector[2] @[PositDef.scala 257:14]
    node _T_189 = bits(valSticky, 2, 2) @[PositDef.scala 258:29]
    io.sticky <= _T_189 @[PositDef.scala 258:17]
    node _T_190 = bits(valStickyAnd, 2, 2) @[PositDef.scala 259:35]
    io.stickyAnd <= _T_190 @[PositDef.scala 259:20]
    
  module ZeroPadRight_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<4>, out : UInt<2>}
    
    node _T_9 = bits(io.in, 3, 1) @[PositDef.scala 139:20]
    io.out <= _T_9 @[PositDef.scala 139:12]
    
  module PositMultiply_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, flip b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, trailingBits : UInt<2>, stickyBit : UInt<1>}
    
    wire abSign : UInt<1> @[PositMultiply.scala 31:20]
    wire abExp : UInt<6> @[PositMultiply.scala 32:19]
    wire abExpTooSmall : UInt<1> @[PositMultiply.scala 33:27]
    wire abExpTooLarge : UInt<1> @[PositMultiply.scala 34:27]
    wire abExpShift : UInt<1> @[PositMultiply.scala 35:24]
    wire finalExpExtended : UInt<6> @[PositMultiply.scala 37:30]
    wire finalExp : UInt<5> @[PositMultiply.scala 38:22]
    wire abUnshiftedProduct : UInt<10> @[PositMultiply.scala 39:32]
    wire abShiftedProduct : UInt<10> @[PositMultiply.scala 40:30]
    wire underflowShift : UInt<4> @[PositMultiply.scala 41:28]
    wire underflowProduct : UInt<3> @[PositMultiply.scala 42:30]
    wire underflowSticky : UInt<1> @[PositMultiply.scala 44:29]
    wire normalTrailingBits : UInt<2> @[PositMultiply.scala 45:32]
    wire normalStickyBit : UInt<1> @[PositMultiply.scala 46:29]
    inst shiftRightWithSticky of ShiftRightSticky_1 @[PositMultiply.scala 49:36]
    shiftRightWithSticky.clock <= clock
    shiftRightWithSticky.reset <= reset
    shiftRightWithSticky.io.in <= abShiftedProduct @[PositMultiply.scala 52:30]
    shiftRightWithSticky.io.shift <= underflowShift @[PositMultiply.scala 53:33]
    underflowProduct <= shiftRightWithSticky.io.out @[PositMultiply.scala 54:19]
    underflowSticky <= shiftRightWithSticky.io.sticky @[PositMultiply.scala 55:19]
    wire unusedStickyAnd : UInt<1> @[PositMultiply.scala 57:29]
    unusedStickyAnd <= shiftRightWithSticky.io.stickyAnd @[PositMultiply.scala 58:19]
    inst zeroPadRight of ZeroPadRight_3 @[PositMultiply.scala 64:28]
    zeroPadRight.clock <= clock
    zeroPadRight.reset <= reset
    node _T_30 = bits(abShiftedProduct, 3, 0) @[PositMultiply.scala 66:41]
    zeroPadRight.io.in <= _T_30 @[PositMultiply.scala 66:22]
    normalTrailingBits <= zeroPadRight.io.out @[PositMultiply.scala 67:24]
    node _T_31 = xor(io.a.sign, io.b.sign) @[PositMultiply.scala 70:23]
    abSign <= _T_31 @[PositMultiply.scala 70:10]
    node _T_33 = cat(UInt<1>("h01"), io.a.fraction) @[Cat.scala 30:58]
    node _T_35 = cat(UInt<1>("h01"), io.b.fraction) @[Cat.scala 30:58]
    node _T_36 = mul(_T_33, _T_35) @[PositMultiply.scala 74:54]
    abUnshiftedProduct <= _T_36 @[PositMultiply.scala 74:22]
    node _T_37 = bits(abUnshiftedProduct, 9, 9) @[PositMultiply.scala 78:35]
    abExpShift <= _T_37 @[PositMultiply.scala 78:14]
    node _T_38 = add(io.a.exponent, io.b.exponent) @[PositMultiply.scala 83:26]
    node _T_39 = tail(_T_38, 1) @[PositMultiply.scala 83:26]
    node _T_40 = add(_T_39, abExpShift) @[PositMultiply.scala 83:42]
    node _T_41 = tail(_T_40, 1) @[PositMultiply.scala 83:42]
    abExp <= _T_41 @[PositMultiply.scala 83:9]
    node _T_42 = bits(abExpShift, 0, 0) @[PositMultiply.scala 88:26]
    when _T_42 : @[PositMultiply.scala 88:30]
      abShiftedProduct <= abUnshiftedProduct @[PositMultiply.scala 89:22]
      skip @[PositMultiply.scala 88:30]
    else : @[PositMultiply.scala 90:16]
      node _T_43 = bits(abUnshiftedProduct, 8, 0) @[PositMultiply.scala 91:47]
      node _T_45 = cat(_T_43, UInt<1>("h00")) @[Cat.scala 30:58]
      abShiftedProduct <= _T_45 @[PositMultiply.scala 91:22]
      skip @[PositMultiply.scala 90:16]
    node _T_47 = lt(abExp, UInt<4>("h0c")) @[PositMultiply.scala 96:27]
    abExpTooSmall <= _T_47 @[PositMultiply.scala 96:17]
    node _T_49 = gt(abExp, UInt<6>("h024")) @[PositMultiply.scala 99:27]
    abExpTooLarge <= _T_49 @[PositMultiply.scala 99:17]
    node _T_51 = sub(abExp, UInt<4>("h0c")) @[PositMultiply.scala 101:29]
    node _T_52 = asUInt(_T_51) @[PositMultiply.scala 101:29]
    node _T_53 = tail(_T_52, 1) @[PositMultiply.scala 101:29]
    finalExpExtended <= _T_53 @[PositMultiply.scala 101:20]
    node _T_54 = bits(finalExpExtended, 4, 0) @[PositMultiply.scala 103:31]
    finalExp <= _T_54 @[PositMultiply.scala 103:12]
    node _T_56 = bits(abExp, 3, 0) @[PositMultiply.scala 108:50]
    node _T_57 = sub(UInt<4>("h0c"), _T_56) @[PositMultiply.scala 108:43]
    node _T_58 = asUInt(_T_57) @[PositMultiply.scala 108:43]
    node _T_59 = tail(_T_58, 1) @[PositMultiply.scala 108:43]
    underflowShift <= _T_59 @[PositMultiply.scala 108:18]
    node _T_60 = or(io.a.isInf, io.b.isInf) @[PositMultiply.scala 110:30]
    io.out.isInf <= _T_60 @[PositMultiply.scala 110:16]
    node _T_62 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 112:21]
    node _T_63 = or(io.a.isZero, io.b.isZero) @[PositMultiply.scala 112:52]
    node _T_64 = and(_T_62, _T_63) @[PositMultiply.scala 112:36]
    io.out.isZero <= _T_64 @[PositMultiply.scala 112:17]
    node _T_66 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 114:19]
    node _T_67 = bits(abSign, 0, 0) @[PositMultiply.scala 114:50]
    node _T_68 = and(_T_66, _T_67) @[PositMultiply.scala 114:34]
    io.out.sign <= _T_68 @[PositMultiply.scala 114:15]
    node _T_69 = or(io.out.isZero, io.out.isInf) @[PositMultiply.scala 116:22]
    when _T_69 : @[PositMultiply.scala 116:39]
      io.out.exponent <= UInt<1>("h00") @[PositMultiply.scala 117:21]
      skip @[PositMultiply.scala 116:39]
    else : @[PositMultiply.scala 118:39]
      node _T_71 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 118:35]
      when _T_71 : @[PositMultiply.scala 118:39]
        io.out.exponent <= UInt<5>("h018") @[PositMultiply.scala 119:21]
        skip @[PositMultiply.scala 118:39]
      else : @[PositMultiply.scala 120:16]
        io.out.exponent <= finalExp @[PositMultiply.scala 121:21]
        skip @[PositMultiply.scala 120:16]
    node _T_73 = or(io.out.isInf, io.out.isZero) @[PositMultiply.scala 124:21]
    node _T_74 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 124:61]
    node _T_75 = or(_T_73, _T_74) @[PositMultiply.scala 124:38]
    when _T_75 : @[PositMultiply.scala 124:65]
      io.out.fraction <= UInt<1>("h00") @[PositMultiply.scala 125:21]
      skip @[PositMultiply.scala 124:65]
    else : @[PositMultiply.scala 126:16]
      node _T_77 = bits(abShiftedProduct, 8, 5) @[PositMultiply.scala 127:40]
      io.out.fraction <= _T_77 @[PositMultiply.scala 127:21]
      skip @[PositMultiply.scala 126:16]
    node _T_78 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 130:21]
    node _T_79 = or(_T_78, io.b.isZero) @[PositMultiply.scala 130:36]
    node _T_80 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 130:74]
    node _T_81 = or(_T_79, _T_80) @[PositMultiply.scala 130:51]
    when _T_81 : @[PositMultiply.scala 130:78]
      io.trailingBits <= UInt<1>("h00") @[PositMultiply.scala 131:21]
      skip @[PositMultiply.scala 130:78]
    else : @[PositMultiply.scala 132:39]
      node _T_83 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 132:35]
      when _T_83 : @[PositMultiply.scala 132:39]
        node _T_84 = bits(underflowProduct, 1, 0) @[PositMultiply.scala 133:40]
        io.trailingBits <= _T_84 @[PositMultiply.scala 133:21]
        skip @[PositMultiply.scala 132:39]
      else : @[PositMultiply.scala 134:16]
        io.trailingBits <= normalTrailingBits @[PositMultiply.scala 135:21]
        skip @[PositMultiply.scala 134:16]
    node _T_85 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 138:21]
    node _T_86 = or(_T_85, io.b.isZero) @[PositMultiply.scala 138:36]
    node _T_87 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 138:74]
    node _T_88 = or(_T_86, _T_87) @[PositMultiply.scala 138:51]
    when _T_88 : @[PositMultiply.scala 138:78]
      io.stickyBit <= UInt<1>("h00") @[PositMultiply.scala 139:18]
      skip @[PositMultiply.scala 138:78]
    else : @[PositMultiply.scala 140:39]
      node _T_90 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 140:35]
      when _T_90 : @[PositMultiply.scala 140:39]
        io.stickyBit <= underflowSticky @[PositMultiply.scala 141:18]
        skip @[PositMultiply.scala 140:39]
      else : @[PositMultiply.scala 142:16]
        io.stickyBit <= normalStickyBit @[PositMultiply.scala 143:18]
        skip @[PositMultiply.scala 142:16]
    node _T_91 = bits(abShiftedProduct, 1, 0) @[PositMultiply.scala 147:40]
    node _T_93 = neq(_T_91, UInt<1>("h00")) @[PositMultiply.scala 147:101]
    normalStickyBit <= _T_93 @[PositMultiply.scala 147:21]
    
  module PositEncode_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {bits : UInt<8>}}
    
    wire signedRegime : SInt<4> @[PositEncode.scala 22:26]
    wire shiftBits : UInt<3> @[PositEncode.scala 24:23]
    wire posRegime : UInt<1> @[PositEncode.scala 26:23]
    wire esAndFraction : SInt<7> @[PositEncode.scala 28:27]
    wire esAndFractionShifted : SInt<7> @[PositEncode.scala 30:34]
    node _T_14 = dshr(esAndFraction, shiftBits) @[PositEncode.scala 37:41]
    esAndFractionShifted <= _T_14 @[PositEncode.scala 37:24]
    wire firstBits : UInt<2> @[PositEncode.scala 39:23]
    node _T_17 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 40:18]
    when _T_17 : @[PositEncode.scala 40:27]
      firstBits <= UInt<2>("h02") @[PositEncode.scala 41:15]
      skip @[PositEncode.scala 40:27]
    else : @[PositEncode.scala 42:16]
      firstBits <= UInt<1>("h01") @[PositEncode.scala 43:15]
      skip @[PositEncode.scala 42:16]
    node _T_20 = bits(io.in.exponent, 0, 0) @[PositEncode.scala 47:55]
    node _T_21 = cat(_T_20, io.in.fraction) @[Cat.scala 30:58]
    node _T_22 = cat(firstBits, _T_21) @[Cat.scala 30:58]
    node _T_23 = asSInt(_T_22) @[PositEncode.scala 47:83]
    esAndFraction <= _T_23 @[PositEncode.scala 47:19]
    wire _T_25 : SInt<4> @[UnpackedPosit.scala 25:22]
    node _T_26 = bits(io.in.exponent, 4, 1) @[UnpackedPosit.scala 26:38]
    node _T_28 = sub(_T_26, UInt<3>("h06")) @[UnpackedPosit.scala 26:92]
    node _T_29 = asUInt(_T_28) @[UnpackedPosit.scala 26:92]
    node _T_30 = tail(_T_29, 1) @[UnpackedPosit.scala 26:92]
    node _T_31 = asSInt(_T_30) @[UnpackedPosit.scala 27:56]
    _T_25 <= _T_31 @[UnpackedPosit.scala 26:12]
    signedRegime <= _T_25 @[PositEncode.scala 53:16]
    node _T_33 = geq(signedRegime, asSInt(UInt<1>("h00"))) @[PositEncode.scala 55:30]
    posRegime <= _T_33 @[PositEncode.scala 55:13]
    node _T_35 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 65:18]
    when _T_35 : @[PositEncode.scala 65:27]
      node _T_36 = bits(signedRegime, 2, 0) @[PositEncode.scala 66:30]
      shiftBits <= _T_36 @[PositEncode.scala 66:15]
      skip @[PositEncode.scala 65:27]
    else : @[PositEncode.scala 68:16]
      node _T_37 = bits(signedRegime, 2, 0) @[PositEncode.scala 72:31]
      node _T_38 = not(_T_37) @[PositEncode.scala 72:18]
      shiftBits <= _T_38 @[PositEncode.scala 72:15]
      skip @[PositEncode.scala 68:16]
    wire outBitsVec : UInt<1>[8] @[PositEncode.scala 75:24]
    node _T_52 = cat(outBitsVec[1], outBitsVec[0]) @[PositEncode.scala 76:29]
    node _T_53 = cat(outBitsVec[3], outBitsVec[2]) @[PositEncode.scala 76:29]
    node _T_54 = cat(_T_53, _T_52) @[PositEncode.scala 76:29]
    node _T_55 = cat(outBitsVec[5], outBitsVec[4]) @[PositEncode.scala 76:29]
    node _T_56 = cat(outBitsVec[7], outBitsVec[6]) @[PositEncode.scala 76:29]
    node _T_57 = cat(_T_56, _T_55) @[PositEncode.scala 76:29]
    node _T_58 = cat(_T_57, _T_54) @[PositEncode.scala 76:29]
    io.out.bits <= _T_58 @[PositEncode.scala 76:15]
    when io.in.isZero : @[PositEncode.scala 77:22]
      outBitsVec[0] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[1] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[2] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[3] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[4] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[5] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[6] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[7] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      skip @[PositEncode.scala 77:22]
    else : @[PositEncode.scala 81:28]
      when io.in.isInf : @[PositEncode.scala 81:28]
        node _T_70 = cat(UInt<1>("h01"), UInt<7>("h00")) @[Cat.scala 30:58]
        node _T_71 = bits(_T_70, 0, 0) @[PositEncode.scala 83:61]
        node _T_72 = bits(_T_70, 1, 1) @[PositEncode.scala 83:61]
        node _T_73 = bits(_T_70, 2, 2) @[PositEncode.scala 83:61]
        node _T_74 = bits(_T_70, 3, 3) @[PositEncode.scala 83:61]
        node _T_75 = bits(_T_70, 4, 4) @[PositEncode.scala 83:61]
        node _T_76 = bits(_T_70, 5, 5) @[PositEncode.scala 83:61]
        node _T_77 = bits(_T_70, 6, 6) @[PositEncode.scala 83:61]
        node _T_78 = bits(_T_70, 7, 7) @[PositEncode.scala 83:61]
        outBitsVec[0] <= _T_71 @[PositEncode.scala 83:16]
        outBitsVec[1] <= _T_72 @[PositEncode.scala 83:16]
        outBitsVec[2] <= _T_73 @[PositEncode.scala 83:16]
        outBitsVec[3] <= _T_74 @[PositEncode.scala 83:16]
        outBitsVec[4] <= _T_75 @[PositEncode.scala 83:16]
        outBitsVec[5] <= _T_76 @[PositEncode.scala 83:16]
        outBitsVec[6] <= _T_77 @[PositEncode.scala 83:16]
        outBitsVec[7] <= _T_78 @[PositEncode.scala 83:16]
        skip @[PositEncode.scala 81:28]
      else : @[PositEncode.scala 85:16]
        outBitsVec[7] <= io.in.sign @[PositEncode.scala 86:25]
        node _T_79 = bits(esAndFractionShifted, 6, 6) @[PositEncode.scala 88:44]
        outBitsVec[6] <= _T_79 @[PositEncode.scala 88:21]
        node _T_80 = bits(esAndFractionShifted, 5, 5) @[PositEncode.scala 88:44]
        outBitsVec[5] <= _T_80 @[PositEncode.scala 88:21]
        node _T_81 = bits(esAndFractionShifted, 4, 4) @[PositEncode.scala 88:44]
        outBitsVec[4] <= _T_81 @[PositEncode.scala 88:21]
        node _T_82 = bits(esAndFractionShifted, 3, 3) @[PositEncode.scala 88:44]
        outBitsVec[3] <= _T_82 @[PositEncode.scala 88:21]
        node _T_83 = bits(esAndFractionShifted, 2, 2) @[PositEncode.scala 88:44]
        outBitsVec[2] <= _T_83 @[PositEncode.scala 88:21]
        node _T_84 = bits(esAndFractionShifted, 1, 1) @[PositEncode.scala 88:44]
        outBitsVec[1] <= _T_84 @[PositEncode.scala 88:21]
        node _T_85 = bits(esAndFractionShifted, 0, 0) @[PositEncode.scala 88:44]
        outBitsVec[0] <= _T_85 @[PositEncode.scala 88:21]
        skip @[PositEncode.scala 85:16]
    
  module PositMultiplyPackedToPacked : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip a : {bits : UInt<8>}, flip b : {bits : UInt<8>}, out : {bits : UInt<8>}, trailingBits : UInt<2>, stickyBit : UInt<1>}
    
    wire decA : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[PositMultiplyPackedToPacked.scala 19:18]
    wire decB : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[PositMultiplyPackedToPacked.scala 20:18]
    wire decOut : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[PositMultiplyPackedToPacked.scala 21:20]
    inst decodeA of PositDecode_3 @[PositMultiplyPackedToPacked.scala 24:23]
    decodeA.clock <= clock
    decodeA.reset <= reset
    decodeA.io.in.bits <= io.a.bits @[PositMultiplyPackedToPacked.scala 25:17]
    decA.fraction <= decodeA.io.out.fraction @[PositMultiplyPackedToPacked.scala 26:8]
    decA.exponent <= decodeA.io.out.exponent @[PositMultiplyPackedToPacked.scala 26:8]
    decA.sign <= decodeA.io.out.sign @[PositMultiplyPackedToPacked.scala 26:8]
    decA.isInf <= decodeA.io.out.isInf @[PositMultiplyPackedToPacked.scala 26:8]
    decA.isZero <= decodeA.io.out.isZero @[PositMultiplyPackedToPacked.scala 26:8]
    inst decodeB of PositDecode_4 @[PositMultiplyPackedToPacked.scala 28:23]
    decodeB.clock <= clock
    decodeB.reset <= reset
    decodeB.io.in.bits <= io.b.bits @[PositMultiplyPackedToPacked.scala 29:17]
    decB.fraction <= decodeB.io.out.fraction @[PositMultiplyPackedToPacked.scala 30:8]
    decB.exponent <= decodeB.io.out.exponent @[PositMultiplyPackedToPacked.scala 30:8]
    decB.sign <= decodeB.io.out.sign @[PositMultiplyPackedToPacked.scala 30:8]
    decB.isInf <= decodeB.io.out.isInf @[PositMultiplyPackedToPacked.scala 30:8]
    decB.isZero <= decodeB.io.out.isZero @[PositMultiplyPackedToPacked.scala 30:8]
    inst multiply of PositMultiply_1 @[PositMultiplyPackedToPacked.scala 32:24]
    multiply.clock <= clock
    multiply.reset <= reset
    multiply.io.a.fraction <= decA.fraction @[PositMultiplyPackedToPacked.scala 33:17]
    multiply.io.a.exponent <= decA.exponent @[PositMultiplyPackedToPacked.scala 33:17]
    multiply.io.a.sign <= decA.sign @[PositMultiplyPackedToPacked.scala 33:17]
    multiply.io.a.isInf <= decA.isInf @[PositMultiplyPackedToPacked.scala 33:17]
    multiply.io.a.isZero <= decA.isZero @[PositMultiplyPackedToPacked.scala 33:17]
    multiply.io.b.fraction <= decB.fraction @[PositMultiplyPackedToPacked.scala 34:17]
    multiply.io.b.exponent <= decB.exponent @[PositMultiplyPackedToPacked.scala 34:17]
    multiply.io.b.sign <= decB.sign @[PositMultiplyPackedToPacked.scala 34:17]
    multiply.io.b.isInf <= decB.isInf @[PositMultiplyPackedToPacked.scala 34:17]
    multiply.io.b.isZero <= decB.isZero @[PositMultiplyPackedToPacked.scala 34:17]
    decOut.fraction <= multiply.io.out.fraction @[PositMultiplyPackedToPacked.scala 35:10]
    decOut.exponent <= multiply.io.out.exponent @[PositMultiplyPackedToPacked.scala 35:10]
    decOut.sign <= multiply.io.out.sign @[PositMultiplyPackedToPacked.scala 35:10]
    decOut.isInf <= multiply.io.out.isInf @[PositMultiplyPackedToPacked.scala 35:10]
    decOut.isZero <= multiply.io.out.isZero @[PositMultiplyPackedToPacked.scala 35:10]
    io.trailingBits <= multiply.io.trailingBits @[PositMultiplyPackedToPacked.scala 36:19]
    io.stickyBit <= multiply.io.stickyBit @[PositMultiplyPackedToPacked.scala 37:16]
    inst encode of PositEncode_2 @[PositMultiplyPackedToPacked.scala 45:22]
    encode.clock <= clock
    encode.reset <= reset
    encode.io.in.fraction <= decOut.fraction @[PositMultiplyPackedToPacked.scala 46:16]
    encode.io.in.exponent <= decOut.exponent @[PositMultiplyPackedToPacked.scala 46:16]
    encode.io.in.sign <= decOut.sign @[PositMultiplyPackedToPacked.scala 46:16]
    encode.io.in.isInf <= decOut.isInf @[PositMultiplyPackedToPacked.scala 46:16]
    encode.io.in.isZero <= decOut.isZero @[PositMultiplyPackedToPacked.scala 46:16]
    io.out.bits <= encode.io.out.bits @[PositMultiplyPackedToPacked.scala 47:10]
    
  module PositEncode_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {bits : UInt<8>}}
    
    wire signedRegime : SInt<4> @[PositEncode.scala 22:26]
    wire shiftBits : UInt<3> @[PositEncode.scala 24:23]
    wire posRegime : UInt<1> @[PositEncode.scala 26:23]
    wire esAndFraction : SInt<7> @[PositEncode.scala 28:27]
    wire esAndFractionShifted : SInt<7> @[PositEncode.scala 30:34]
    node _T_14 = dshr(esAndFraction, shiftBits) @[PositEncode.scala 37:41]
    esAndFractionShifted <= _T_14 @[PositEncode.scala 37:24]
    wire firstBits : UInt<2> @[PositEncode.scala 39:23]
    node _T_17 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 40:18]
    when _T_17 : @[PositEncode.scala 40:27]
      firstBits <= UInt<2>("h02") @[PositEncode.scala 41:15]
      skip @[PositEncode.scala 40:27]
    else : @[PositEncode.scala 42:16]
      firstBits <= UInt<1>("h01") @[PositEncode.scala 43:15]
      skip @[PositEncode.scala 42:16]
    node _T_20 = bits(io.in.exponent, 0, 0) @[PositEncode.scala 47:55]
    node _T_21 = cat(_T_20, io.in.fraction) @[Cat.scala 30:58]
    node _T_22 = cat(firstBits, _T_21) @[Cat.scala 30:58]
    node _T_23 = asSInt(_T_22) @[PositEncode.scala 47:83]
    esAndFraction <= _T_23 @[PositEncode.scala 47:19]
    wire _T_25 : SInt<4> @[UnpackedPosit.scala 25:22]
    node _T_26 = bits(io.in.exponent, 4, 1) @[UnpackedPosit.scala 26:38]
    node _T_28 = sub(_T_26, UInt<3>("h06")) @[UnpackedPosit.scala 26:92]
    node _T_29 = asUInt(_T_28) @[UnpackedPosit.scala 26:92]
    node _T_30 = tail(_T_29, 1) @[UnpackedPosit.scala 26:92]
    node _T_31 = asSInt(_T_30) @[UnpackedPosit.scala 27:56]
    _T_25 <= _T_31 @[UnpackedPosit.scala 26:12]
    signedRegime <= _T_25 @[PositEncode.scala 53:16]
    node _T_33 = geq(signedRegime, asSInt(UInt<1>("h00"))) @[PositEncode.scala 55:30]
    posRegime <= _T_33 @[PositEncode.scala 55:13]
    node _T_35 = eq(posRegime, UInt<1>("h01")) @[PositEncode.scala 65:18]
    when _T_35 : @[PositEncode.scala 65:27]
      node _T_36 = bits(signedRegime, 2, 0) @[PositEncode.scala 66:30]
      shiftBits <= _T_36 @[PositEncode.scala 66:15]
      skip @[PositEncode.scala 65:27]
    else : @[PositEncode.scala 68:16]
      node _T_37 = bits(signedRegime, 2, 0) @[PositEncode.scala 72:31]
      node _T_38 = not(_T_37) @[PositEncode.scala 72:18]
      shiftBits <= _T_38 @[PositEncode.scala 72:15]
      skip @[PositEncode.scala 68:16]
    wire outBitsVec : UInt<1>[8] @[PositEncode.scala 75:24]
    node _T_52 = cat(outBitsVec[1], outBitsVec[0]) @[PositEncode.scala 76:29]
    node _T_53 = cat(outBitsVec[3], outBitsVec[2]) @[PositEncode.scala 76:29]
    node _T_54 = cat(_T_53, _T_52) @[PositEncode.scala 76:29]
    node _T_55 = cat(outBitsVec[5], outBitsVec[4]) @[PositEncode.scala 76:29]
    node _T_56 = cat(outBitsVec[7], outBitsVec[6]) @[PositEncode.scala 76:29]
    node _T_57 = cat(_T_56, _T_55) @[PositEncode.scala 76:29]
    node _T_58 = cat(_T_57, _T_54) @[PositEncode.scala 76:29]
    io.out.bits <= _T_58 @[PositEncode.scala 76:15]
    when io.in.isZero : @[PositEncode.scala 77:22]
      outBitsVec[0] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[1] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[2] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[3] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[4] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[5] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[6] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      outBitsVec[7] <= UInt<1>("h00") @[PositEncode.scala 80:16]
      skip @[PositEncode.scala 77:22]
    else : @[PositEncode.scala 81:28]
      when io.in.isInf : @[PositEncode.scala 81:28]
        node _T_70 = cat(UInt<1>("h01"), UInt<7>("h00")) @[Cat.scala 30:58]
        node _T_71 = bits(_T_70, 0, 0) @[PositEncode.scala 83:61]
        node _T_72 = bits(_T_70, 1, 1) @[PositEncode.scala 83:61]
        node _T_73 = bits(_T_70, 2, 2) @[PositEncode.scala 83:61]
        node _T_74 = bits(_T_70, 3, 3) @[PositEncode.scala 83:61]
        node _T_75 = bits(_T_70, 4, 4) @[PositEncode.scala 83:61]
        node _T_76 = bits(_T_70, 5, 5) @[PositEncode.scala 83:61]
        node _T_77 = bits(_T_70, 6, 6) @[PositEncode.scala 83:61]
        node _T_78 = bits(_T_70, 7, 7) @[PositEncode.scala 83:61]
        outBitsVec[0] <= _T_71 @[PositEncode.scala 83:16]
        outBitsVec[1] <= _T_72 @[PositEncode.scala 83:16]
        outBitsVec[2] <= _T_73 @[PositEncode.scala 83:16]
        outBitsVec[3] <= _T_74 @[PositEncode.scala 83:16]
        outBitsVec[4] <= _T_75 @[PositEncode.scala 83:16]
        outBitsVec[5] <= _T_76 @[PositEncode.scala 83:16]
        outBitsVec[6] <= _T_77 @[PositEncode.scala 83:16]
        outBitsVec[7] <= _T_78 @[PositEncode.scala 83:16]
        skip @[PositEncode.scala 81:28]
      else : @[PositEncode.scala 85:16]
        outBitsVec[7] <= io.in.sign @[PositEncode.scala 86:25]
        node _T_79 = bits(esAndFractionShifted, 6, 6) @[PositEncode.scala 88:44]
        outBitsVec[6] <= _T_79 @[PositEncode.scala 88:21]
        node _T_80 = bits(esAndFractionShifted, 5, 5) @[PositEncode.scala 88:44]
        outBitsVec[5] <= _T_80 @[PositEncode.scala 88:21]
        node _T_81 = bits(esAndFractionShifted, 4, 4) @[PositEncode.scala 88:44]
        outBitsVec[4] <= _T_81 @[PositEncode.scala 88:21]
        node _T_82 = bits(esAndFractionShifted, 3, 3) @[PositEncode.scala 88:44]
        outBitsVec[3] <= _T_82 @[PositEncode.scala 88:21]
        node _T_83 = bits(esAndFractionShifted, 2, 2) @[PositEncode.scala 88:44]
        outBitsVec[2] <= _T_83 @[PositEncode.scala 88:21]
        node _T_84 = bits(esAndFractionShifted, 1, 1) @[PositEncode.scala 88:44]
        outBitsVec[1] <= _T_84 @[PositEncode.scala 88:21]
        node _T_85 = bits(esAndFractionShifted, 0, 0) @[PositEncode.scala 88:44]
        outBitsVec[0] <= _T_85 @[PositEncode.scala 88:21]
        skip @[PositEncode.scala 85:16]
    
  module Test : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst gen of DataGen @[Test.scala 34:19]
    gen.clock <= clock
    gen.reset <= reset
    inst multiply of PositMultiply @[Test.scala 35:24]
    multiply.clock <= clock
    multiply.reset <= reset
    multiply.io.a.fraction <= gen.io.a.fraction @[Test.scala 36:17]
    multiply.io.a.exponent <= gen.io.a.exponent @[Test.scala 36:17]
    multiply.io.a.sign <= gen.io.a.sign @[Test.scala 36:17]
    multiply.io.a.isInf <= gen.io.a.isInf @[Test.scala 36:17]
    multiply.io.a.isZero <= gen.io.a.isZero @[Test.scala 36:17]
    multiply.io.b.fraction <= gen.io.b.fraction @[Test.scala 37:17]
    multiply.io.b.exponent <= gen.io.b.exponent @[Test.scala 37:17]
    multiply.io.b.sign <= gen.io.b.sign @[Test.scala 37:17]
    multiply.io.b.isInf <= gen.io.b.isInf @[Test.scala 37:17]
    multiply.io.b.isZero <= gen.io.b.isZero @[Test.scala 37:17]
    inst encodeTestA of PositEncode @[Test.scala 39:27]
    encodeTestA.clock <= clock
    encodeTestA.reset <= reset
    encodeTestA.io.in.fraction <= gen.io.a.fraction @[Test.scala 40:21]
    encodeTestA.io.in.exponent <= gen.io.a.exponent @[Test.scala 40:21]
    encodeTestA.io.in.sign <= gen.io.a.sign @[Test.scala 40:21]
    encodeTestA.io.in.isInf <= gen.io.a.isInf @[Test.scala 40:21]
    encodeTestA.io.in.isZero <= gen.io.a.isZero @[Test.scala 40:21]
    wire aPacked : {bits : UInt<8>} @[Test.scala 41:21]
    aPacked.bits <= encodeTestA.io.out.bits @[Test.scala 42:11]
    inst decodeTestA of PositDecode @[Test.scala 44:27]
    decodeTestA.clock <= clock
    decodeTestA.reset <= reset
    decodeTestA.io.in.bits <= aPacked.bits @[Test.scala 45:21]
    wire aUnpacked : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[Test.scala 46:23]
    aUnpacked.fraction <= decodeTestA.io.out.fraction @[Test.scala 47:13]
    aUnpacked.exponent <= decodeTestA.io.out.exponent @[Test.scala 47:13]
    aUnpacked.sign <= decodeTestA.io.out.sign @[Test.scala 47:13]
    aUnpacked.isInf <= decodeTestA.io.out.isInf @[Test.scala 47:13]
    aUnpacked.isZero <= decodeTestA.io.out.isZero @[Test.scala 47:13]
    inst encodeTestB of PositEncode_1 @[Test.scala 49:27]
    encodeTestB.clock <= clock
    encodeTestB.reset <= reset
    encodeTestB.io.in.fraction <= gen.io.b.fraction @[Test.scala 50:21]
    encodeTestB.io.in.exponent <= gen.io.b.exponent @[Test.scala 50:21]
    encodeTestB.io.in.sign <= gen.io.b.sign @[Test.scala 50:21]
    encodeTestB.io.in.isInf <= gen.io.b.isInf @[Test.scala 50:21]
    encodeTestB.io.in.isZero <= gen.io.b.isZero @[Test.scala 50:21]
    wire bPacked : {bits : UInt<8>} @[Test.scala 51:21]
    bPacked.bits <= encodeTestB.io.out.bits @[Test.scala 52:11]
    inst decodeTestB of PositDecode_1 @[Test.scala 54:27]
    decodeTestB.clock <= clock
    decodeTestB.reset <= reset
    decodeTestB.io.in.bits <= bPacked.bits @[Test.scala 55:21]
    wire bUnpacked : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[Test.scala 56:23]
    bUnpacked.fraction <= decodeTestB.io.out.fraction @[Test.scala 57:13]
    bUnpacked.exponent <= decodeTestB.io.out.exponent @[Test.scala 57:13]
    bUnpacked.sign <= decodeTestB.io.out.sign @[Test.scala 57:13]
    bUnpacked.isInf <= decodeTestB.io.out.isInf @[Test.scala 57:13]
    bUnpacked.isZero <= decodeTestB.io.out.isZero @[Test.scala 57:13]
    wire cPacked : {bits : UInt<8>} @[Test.scala 59:21]
    inst decodeTestC of PositDecode_2 @[Test.scala 62:27]
    decodeTestC.clock <= clock
    decodeTestC.reset <= reset
    decodeTestC.io.in.bits <= cPacked.bits @[Test.scala 63:21]
    wire cUnpacked : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[Test.scala 64:23]
    cUnpacked.fraction <= decodeTestC.io.out.fraction @[Test.scala 65:13]
    cUnpacked.exponent <= decodeTestC.io.out.exponent @[Test.scala 65:13]
    cUnpacked.sign <= decodeTestC.io.out.sign @[Test.scala 65:13]
    cUnpacked.isInf <= decodeTestC.io.out.isInf @[Test.scala 65:13]
    cUnpacked.isZero <= decodeTestC.io.out.isZero @[Test.scala 65:13]
    wire trailingBits : UInt<2> @[Test.scala 67:26]
    wire stickyBit : UInt<1> @[Test.scala 68:23]
    trailingBits <= multiply.io.trailingBits @[Test.scala 70:16]
    stickyBit <= multiply.io.stickyBit @[Test.scala 71:13]
    wire output : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[Test.scala 73:20]
    output.fraction <= multiply.io.out.fraction @[Test.scala 75:10]
    output.exponent <= multiply.io.out.exponent @[Test.scala 75:10]
    output.sign <= multiply.io.out.sign @[Test.scala 75:10]
    output.isInf <= multiply.io.out.isInf @[Test.scala 75:10]
    output.isZero <= multiply.io.out.isZero @[Test.scala 75:10]
    inst countingZeros of CountLeadingZeros_3 @[Test.scala 78:29]
    countingZeros.clock <= clock
    countingZeros.reset <= reset
    wire countTest : UInt<6> @[Test.scala 79:23]
    countTest <= UInt<6>("h0f") @[Test.scala 80:13]
    countingZeros.io.in <= countTest @[Test.scala 81:23]
    wire countOutput : UInt<8> @[Test.scala 82:25]
    countOutput <= countingZeros.io.out @[Test.scala 83:15]
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 26:33]
    when UInt<1>("h01") : @[Counter.scala 63:17]
      node _T_21 = eq(value, UInt<8>("h0ff")) @[Counter.scala 34:24]
      node _T_23 = add(value, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_24 = tail(_T_23, 1) @[Counter.scala 35:22]
      value <= _T_24 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_25 = and(UInt<1>("h01"), _T_21) @[Counter.scala 64:20]
    wire trailingBits2 : UInt<2> @[Test.scala 86:27]
    wire stickyBit2 : UInt<1> @[Test.scala 87:24]
    inst endToEndTest of PositMultiplyPackedToPacked @[Test.scala 88:28]
    endToEndTest.clock <= clock
    endToEndTest.reset <= reset
    endToEndTest.io.a.bits <= aPacked.bits @[Test.scala 89:21]
    endToEndTest.io.b.bits <= bPacked.bits @[Test.scala 90:21]
    cPacked.bits <= endToEndTest.io.out.bits @[Test.scala 91:11]
    trailingBits2 <= endToEndTest.io.trailingBits @[Test.scala 92:17]
    stickyBit2 <= endToEndTest.io.stickyBit @[Test.scala 93:14]
    inst encodeTestOut of PositEncode_3 @[Test.scala 95:29]
    encodeTestOut.clock <= clock
    encodeTestOut.reset <= reset
    encodeTestOut.io.in.fraction <= multiply.io.out.fraction @[Test.scala 96:23]
    encodeTestOut.io.in.exponent <= multiply.io.out.exponent @[Test.scala 96:23]
    encodeTestOut.io.in.sign <= multiply.io.out.sign @[Test.scala 96:23]
    encodeTestOut.io.in.isInf <= multiply.io.out.isInf @[Test.scala 96:23]
    encodeTestOut.io.in.isZero <= multiply.io.out.isZero @[Test.scala 96:23]
    wire outPacked : {bits : UInt<8>} @[Test.scala 97:23]
    outPacked.bits <= encodeTestOut.io.out.bits @[Test.scala 98:13]
    node _T_30 = eq(value, UInt<6>("h038")) @[Test.scala 100:15]
    when _T_30 : @[Test.scala 100:25]
      node _T_31 = bits(reset, 0, 0) @[Test.scala 102:11]
      node _T_33 = eq(_T_31, UInt<1>("h00")) @[Test.scala 102:11]
      when _T_33 : @[Test.scala 102:11]
        printf(clock, UInt<1>(1), "a.exponent is %b \n", gen.io.a.exponent) @[Test.scala 102:11]
        skip @[Test.scala 102:11]
      node _T_34 = bits(reset, 0, 0) @[Test.scala 103:11]
      node _T_36 = eq(_T_34, UInt<1>("h00")) @[Test.scala 103:11]
      when _T_36 : @[Test.scala 103:11]
        printf(clock, UInt<1>(1), "a.fraction is %b \n", gen.io.a.fraction) @[Test.scala 103:11]
        skip @[Test.scala 103:11]
      node _T_37 = bits(reset, 0, 0) @[Test.scala 104:11]
      node _T_39 = eq(_T_37, UInt<1>("h00")) @[Test.scala 104:11]
      when _T_39 : @[Test.scala 104:11]
        printf(clock, UInt<1>(1), "b.exponent is %b \n", gen.io.b.exponent) @[Test.scala 104:11]
        skip @[Test.scala 104:11]
      node _T_40 = bits(reset, 0, 0) @[Test.scala 105:11]
      node _T_42 = eq(_T_40, UInt<1>("h00")) @[Test.scala 105:11]
      when _T_42 : @[Test.scala 105:11]
        printf(clock, UInt<1>(1), "b.fraction is %b \n", gen.io.b.fraction) @[Test.scala 105:11]
        skip @[Test.scala 105:11]
      node _T_43 = bits(reset, 0, 0) @[Test.scala 107:11]
      node _T_45 = eq(_T_43, UInt<1>("h00")) @[Test.scala 107:11]
      when _T_45 : @[Test.scala 107:11]
        printf(clock, UInt<1>(1), "aPacked is %b \n", aPacked.bits) @[Test.scala 107:11]
        skip @[Test.scala 107:11]
      node _T_46 = bits(reset, 0, 0) @[Test.scala 108:11]
      node _T_48 = eq(_T_46, UInt<1>("h00")) @[Test.scala 108:11]
      when _T_48 : @[Test.scala 108:11]
        printf(clock, UInt<1>(1), "now testing decoding for packed a... \n") @[Test.scala 108:11]
        skip @[Test.scala 108:11]
      node _T_49 = bits(reset, 0, 0) @[Test.scala 109:11]
      node _T_51 = eq(_T_49, UInt<1>("h00")) @[Test.scala 109:11]
      when _T_51 : @[Test.scala 109:11]
        printf(clock, UInt<1>(1), "sign is %b \n", aUnpacked.sign) @[Test.scala 109:11]
        skip @[Test.scala 109:11]
      node _T_52 = bits(reset, 0, 0) @[Test.scala 110:11]
      node _T_54 = eq(_T_52, UInt<1>("h00")) @[Test.scala 110:11]
      when _T_54 : @[Test.scala 110:11]
        printf(clock, UInt<1>(1), "isInf is %b \n", aUnpacked.isInf) @[Test.scala 110:11]
        skip @[Test.scala 110:11]
      node _T_55 = bits(reset, 0, 0) @[Test.scala 111:11]
      node _T_57 = eq(_T_55, UInt<1>("h00")) @[Test.scala 111:11]
      when _T_57 : @[Test.scala 111:11]
        printf(clock, UInt<1>(1), "isZero is %b \n", aUnpacked.isZero) @[Test.scala 111:11]
        skip @[Test.scala 111:11]
      node _T_58 = bits(reset, 0, 0) @[Test.scala 112:11]
      node _T_60 = eq(_T_58, UInt<1>("h00")) @[Test.scala 112:11]
      when _T_60 : @[Test.scala 112:11]
        printf(clock, UInt<1>(1), "exponent is %b \n", aUnpacked.exponent) @[Test.scala 112:11]
        skip @[Test.scala 112:11]
      node _T_61 = bits(reset, 0, 0) @[Test.scala 113:11]
      node _T_63 = eq(_T_61, UInt<1>("h00")) @[Test.scala 113:11]
      when _T_63 : @[Test.scala 113:11]
        printf(clock, UInt<1>(1), "fraction is %b \n", aUnpacked.fraction) @[Test.scala 113:11]
        skip @[Test.scala 113:11]
      node _T_64 = bits(reset, 0, 0) @[Test.scala 114:11]
      node _T_66 = eq(_T_64, UInt<1>("h00")) @[Test.scala 114:11]
      when _T_66 : @[Test.scala 114:11]
        printf(clock, UInt<1>(1), "\n") @[Test.scala 114:11]
        skip @[Test.scala 114:11]
      node _T_67 = bits(reset, 0, 0) @[Test.scala 115:11]
      node _T_69 = eq(_T_67, UInt<1>("h00")) @[Test.scala 115:11]
      when _T_69 : @[Test.scala 115:11]
        printf(clock, UInt<1>(1), "bPacked is %b \n", bPacked.bits) @[Test.scala 115:11]
        skip @[Test.scala 115:11]
      node _T_70 = bits(reset, 0, 0) @[Test.scala 116:11]
      node _T_72 = eq(_T_70, UInt<1>("h00")) @[Test.scala 116:11]
      when _T_72 : @[Test.scala 116:11]
        printf(clock, UInt<1>(1), "now testing decoding for packed b... \n") @[Test.scala 116:11]
        skip @[Test.scala 116:11]
      node _T_73 = bits(reset, 0, 0) @[Test.scala 117:11]
      node _T_75 = eq(_T_73, UInt<1>("h00")) @[Test.scala 117:11]
      when _T_75 : @[Test.scala 117:11]
        printf(clock, UInt<1>(1), "sign is %b \n", bUnpacked.sign) @[Test.scala 117:11]
        skip @[Test.scala 117:11]
      node _T_76 = bits(reset, 0, 0) @[Test.scala 118:11]
      node _T_78 = eq(_T_76, UInt<1>("h00")) @[Test.scala 118:11]
      when _T_78 : @[Test.scala 118:11]
        printf(clock, UInt<1>(1), "isInf is %b \n", bUnpacked.isInf) @[Test.scala 118:11]
        skip @[Test.scala 118:11]
      node _T_79 = bits(reset, 0, 0) @[Test.scala 119:11]
      node _T_81 = eq(_T_79, UInt<1>("h00")) @[Test.scala 119:11]
      when _T_81 : @[Test.scala 119:11]
        printf(clock, UInt<1>(1), "isZero is %b \n", bUnpacked.isZero) @[Test.scala 119:11]
        skip @[Test.scala 119:11]
      node _T_82 = bits(reset, 0, 0) @[Test.scala 120:11]
      node _T_84 = eq(_T_82, UInt<1>("h00")) @[Test.scala 120:11]
      when _T_84 : @[Test.scala 120:11]
        printf(clock, UInt<1>(1), "exponent is %b \n", bUnpacked.exponent) @[Test.scala 120:11]
        skip @[Test.scala 120:11]
      node _T_85 = bits(reset, 0, 0) @[Test.scala 121:11]
      node _T_87 = eq(_T_85, UInt<1>("h00")) @[Test.scala 121:11]
      when _T_87 : @[Test.scala 121:11]
        printf(clock, UInt<1>(1), "fraction is %b \n", bUnpacked.fraction) @[Test.scala 121:11]
        skip @[Test.scala 121:11]
      node _T_88 = bits(reset, 0, 0) @[Test.scala 122:11]
      node _T_90 = eq(_T_88, UInt<1>("h00")) @[Test.scala 122:11]
      when _T_90 : @[Test.scala 122:11]
        printf(clock, UInt<1>(1), "\n") @[Test.scala 122:11]
        skip @[Test.scala 122:11]
      node _T_91 = bits(reset, 0, 0) @[Test.scala 132:11]
      node _T_93 = eq(_T_91, UInt<1>("h00")) @[Test.scala 132:11]
      when _T_93 : @[Test.scala 132:11]
        printf(clock, UInt<1>(1), "\n") @[Test.scala 132:11]
        skip @[Test.scala 132:11]
      node _T_94 = bits(reset, 0, 0) @[Test.scala 133:11]
      node _T_96 = eq(_T_94, UInt<1>("h00")) @[Test.scala 133:11]
      when _T_96 : @[Test.scala 133:11]
        printf(clock, UInt<1>(1), "counting leading zeros of %b \n", countTest) @[Test.scala 133:11]
        skip @[Test.scala 133:11]
      node _T_97 = bits(reset, 0, 0) @[Test.scala 134:11]
      node _T_99 = eq(_T_97, UInt<1>("h00")) @[Test.scala 134:11]
      when _T_99 : @[Test.scala 134:11]
        printf(clock, UInt<1>(1), "output is %d \n", countOutput) @[Test.scala 134:11]
        skip @[Test.scala 134:11]
      node _T_100 = bits(reset, 0, 0) @[Test.scala 135:11]
      node _T_102 = eq(_T_100, UInt<1>("h00")) @[Test.scala 135:11]
      when _T_102 : @[Test.scala 135:11]
        printf(clock, UInt<1>(1), "\n") @[Test.scala 135:11]
        skip @[Test.scala 135:11]
      node _T_103 = bits(reset, 0, 0) @[Test.scala 137:11]
      node _T_105 = eq(_T_103, UInt<1>("h00")) @[Test.scala 137:11]
      when _T_105 : @[Test.scala 137:11]
        printf(clock, UInt<1>(1), "out.sign is %b \n", multiply.io.out.sign) @[Test.scala 137:11]
        skip @[Test.scala 137:11]
      node _T_106 = bits(reset, 0, 0) @[Test.scala 138:11]
      node _T_108 = eq(_T_106, UInt<1>("h00")) @[Test.scala 138:11]
      when _T_108 : @[Test.scala 138:11]
        printf(clock, UInt<1>(1), "out.isZero is %b \n", multiply.io.out.isZero) @[Test.scala 138:11]
        skip @[Test.scala 138:11]
      node _T_109 = bits(reset, 0, 0) @[Test.scala 139:11]
      node _T_111 = eq(_T_109, UInt<1>("h00")) @[Test.scala 139:11]
      when _T_111 : @[Test.scala 139:11]
        printf(clock, UInt<1>(1), "out.isInf is %b \n", multiply.io.out.isInf) @[Test.scala 139:11]
        skip @[Test.scala 139:11]
      node _T_112 = bits(reset, 0, 0) @[Test.scala 140:11]
      node _T_114 = eq(_T_112, UInt<1>("h00")) @[Test.scala 140:11]
      when _T_114 : @[Test.scala 140:11]
        printf(clock, UInt<1>(1), "out.trailingBits is %b \n", trailingBits) @[Test.scala 140:11]
        skip @[Test.scala 140:11]
      node _T_115 = bits(reset, 0, 0) @[Test.scala 141:11]
      node _T_117 = eq(_T_115, UInt<1>("h00")) @[Test.scala 141:11]
      when _T_117 : @[Test.scala 141:11]
        printf(clock, UInt<1>(1), "out.stickyBit is %b \n", stickyBit) @[Test.scala 141:11]
        skip @[Test.scala 141:11]
      node _T_118 = bits(reset, 0, 0) @[Test.scala 143:11]
      node _T_120 = eq(_T_118, UInt<1>("h00")) @[Test.scala 143:11]
      when _T_120 : @[Test.scala 143:11]
        printf(clock, UInt<1>(1), "out.exponent is %b \n", multiply.io.out.exponent) @[Test.scala 143:11]
        skip @[Test.scala 143:11]
      node _T_121 = bits(reset, 0, 0) @[Test.scala 144:11]
      node _T_123 = eq(_T_121, UInt<1>("h00")) @[Test.scala 144:11]
      when _T_123 : @[Test.scala 144:11]
        printf(clock, UInt<1>(1), "out.fraction is %b \n", multiply.io.out.fraction) @[Test.scala 144:11]
        skip @[Test.scala 144:11]
      node _T_124 = bits(reset, 0, 0) @[Test.scala 145:11]
      node _T_126 = eq(_T_124, UInt<1>("h00")) @[Test.scala 145:11]
      when _T_126 : @[Test.scala 145:11]
        printf(clock, UInt<1>(1), "outPacked is %b", outPacked.bits) @[Test.scala 145:11]
        skip @[Test.scala 145:11]
      node _T_127 = bits(reset, 0, 0) @[Test.scala 146:11]
      node _T_129 = eq(_T_127, UInt<1>("h00")) @[Test.scala 146:11]
      when _T_129 : @[Test.scala 146:11]
        printf(clock, UInt<1>(1), "\n \n") @[Test.scala 146:11]
        skip @[Test.scala 146:11]
      node _T_130 = bits(reset, 0, 0) @[Test.scala 147:11]
      node _T_132 = eq(_T_130, UInt<1>("h00")) @[Test.scala 147:11]
      when _T_132 : @[Test.scala 147:11]
        printf(clock, UInt<1>(1), "now testing packed to packed multiplication (end to end) \n") @[Test.scala 147:11]
        skip @[Test.scala 147:11]
      node _T_133 = bits(reset, 0, 0) @[Test.scala 148:11]
      node _T_135 = eq(_T_133, UInt<1>("h00")) @[Test.scala 148:11]
      when _T_135 : @[Test.scala 148:11]
        printf(clock, UInt<1>(1), "results: \n") @[Test.scala 148:11]
        skip @[Test.scala 148:11]
      node _T_136 = bits(reset, 0, 0) @[Test.scala 149:11]
      node _T_138 = eq(_T_136, UInt<1>("h00")) @[Test.scala 149:11]
      when _T_138 : @[Test.scala 149:11]
        printf(clock, UInt<1>(1), "%b is the packed output \n", cPacked.bits) @[Test.scala 149:11]
        skip @[Test.scala 149:11]
      node _T_139 = bits(reset, 0, 0) @[Test.scala 150:11]
      node _T_141 = eq(_T_139, UInt<1>("h00")) @[Test.scala 150:11]
      when _T_141 : @[Test.scala 150:11]
        printf(clock, UInt<1>(1), "sign is %b \n", cUnpacked.sign) @[Test.scala 150:11]
        skip @[Test.scala 150:11]
      node _T_142 = bits(reset, 0, 0) @[Test.scala 151:11]
      node _T_144 = eq(_T_142, UInt<1>("h00")) @[Test.scala 151:11]
      when _T_144 : @[Test.scala 151:11]
        printf(clock, UInt<1>(1), "isInf is %b \n", cUnpacked.isInf) @[Test.scala 151:11]
        skip @[Test.scala 151:11]
      node _T_145 = bits(reset, 0, 0) @[Test.scala 152:11]
      node _T_147 = eq(_T_145, UInt<1>("h00")) @[Test.scala 152:11]
      when _T_147 : @[Test.scala 152:11]
        printf(clock, UInt<1>(1), "isZero is %b \n", cUnpacked.isZero) @[Test.scala 152:11]
        skip @[Test.scala 152:11]
      node _T_148 = bits(reset, 0, 0) @[Test.scala 153:11]
      node _T_150 = eq(_T_148, UInt<1>("h00")) @[Test.scala 153:11]
      when _T_150 : @[Test.scala 153:11]
        printf(clock, UInt<1>(1), "exponent is %b \n", cUnpacked.exponent) @[Test.scala 153:11]
        skip @[Test.scala 153:11]
      node _T_151 = bits(reset, 0, 0) @[Test.scala 154:11]
      node _T_153 = eq(_T_151, UInt<1>("h00")) @[Test.scala 154:11]
      when _T_153 : @[Test.scala 154:11]
        printf(clock, UInt<1>(1), "fraction is %b \n", cUnpacked.fraction) @[Test.scala 154:11]
        skip @[Test.scala 154:11]
      node _T_154 = bits(reset, 0, 0) @[Test.scala 155:11]
      node _T_156 = eq(_T_154, UInt<1>("h00")) @[Test.scala 155:11]
      when _T_156 : @[Test.scala 155:11]
        printf(clock, UInt<1>(1), "\n") @[Test.scala 155:11]
        skip @[Test.scala 155:11]
      skip @[Test.scala 100:25]
    
