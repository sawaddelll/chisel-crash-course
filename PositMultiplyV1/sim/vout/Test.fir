;buildInfoPackage: chisel3, version: 3.1.8, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-07-08 17:44:42.884, builtAtMillis: 1562607882884
circuit Test : 
  module DataGen : 
    input clock : Clock
    input reset : UInt<1>
    output io : {a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    io.a.isZero <= UInt<1>("h00") @[Test.scala 15:16]
    io.a.isInf <= UInt<1>("h00") @[Test.scala 16:16]
    io.a.sign <= UInt<1>("h00") @[Test.scala 17:16]
    io.b.sign <= UInt<1>("h00") @[Test.scala 19:14]
    io.b.isInf <= UInt<1>("h00") @[Test.scala 20:16]
    io.b.isZero <= UInt<1>("h00") @[Test.scala 21:16]
    io.a.exponent <= UInt<5>("h0e") @[Test.scala 23:17]
    io.a.fraction <= UInt<4>("h04") @[Test.scala 24:17]
    io.b.exponent <= UInt<5>("h0f") @[Test.scala 26:17]
    io.b.fraction <= UInt<4>("h00") @[Test.scala 27:17]
    
  module ZeroPadRight : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<10>, out : UInt<3>}
    
    node _T_9 = bits(io.in, 9, 6) @[PositDef.scala 139:20]
    io.out <= _T_9 @[PositDef.scala 139:12]
    
  module ShiftRightSticky : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<10>, flip shift : UInt<4>, out : UInt<3>, sticky : UInt<1>, stickyAnd : UInt<1>}
    
    wire valVector : UInt<3>[3] @[PositDef.scala 168:23]
    wire valVectorOfVecs : UInt<1>[3][3] @[PositDef.scala 169:29]
    node _T_109 = cat(valVectorOfVecs[2][2], valVectorOfVecs[2][1]) @[PositDef.scala 171:40]
    node _T_110 = cat(_T_109, valVectorOfVecs[2][0]) @[PositDef.scala 171:40]
    valVector[2] <= _T_110 @[PositDef.scala 171:18]
    node _T_111 = cat(valVectorOfVecs[1][2], valVectorOfVecs[1][1]) @[PositDef.scala 171:40]
    node _T_112 = cat(_T_111, valVectorOfVecs[1][0]) @[PositDef.scala 171:40]
    valVector[1] <= _T_112 @[PositDef.scala 171:18]
    node _T_113 = cat(valVectorOfVecs[0][2], valVectorOfVecs[0][1]) @[PositDef.scala 171:40]
    node _T_114 = cat(_T_113, valVectorOfVecs[0][0]) @[PositDef.scala 171:40]
    valVector[0] <= _T_114 @[PositDef.scala 171:18]
    wire valSticky : UInt<3> @[PositDef.scala 175:23]
    wire valStickyVec : UInt<1>[3] @[PositDef.scala 176:26]
    node _T_124 = cat(valStickyVec[2], valStickyVec[1]) @[PositDef.scala 177:29]
    node _T_125 = cat(_T_124, valStickyVec[0]) @[PositDef.scala 177:29]
    valSticky <= _T_125 @[PositDef.scala 177:13]
    wire valStickyAnd : UInt<3> @[PositDef.scala 179:26]
    wire valStickyAndVec : UInt<1>[3] @[PositDef.scala 180:29]
    node _T_135 = cat(valStickyAndVec[2], valStickyAndVec[1]) @[PositDef.scala 181:35]
    node _T_136 = cat(_T_135, valStickyAndVec[0]) @[PositDef.scala 181:35]
    valStickyAnd <= _T_136 @[PositDef.scala 181:16]
    wire maxShift : UInt<1> @[PositDef.scala 183:22]
    inst padding of ZeroPadRight @[PositDef.scala 185:23]
    padding.clock <= clock
    padding.reset <= reset
    padding.io.in <= io.in @[PositDef.scala 186:17]
    node _T_138 = bits(padding.io.out, 0, 0) @[PositDef.scala 189:44]
    valVectorOfVecs[0][0] <= _T_138 @[PositDef.scala 189:27]
    node _T_139 = bits(padding.io.out, 1, 1) @[PositDef.scala 189:44]
    valVectorOfVecs[0][1] <= _T_139 @[PositDef.scala 189:27]
    node _T_140 = bits(padding.io.out, 2, 2) @[PositDef.scala 189:44]
    valVectorOfVecs[0][2] <= _T_140 @[PositDef.scala 189:27]
    node _T_141 = bits(io.in, 6, 0) @[PositDef.scala 196:29]
    node _T_143 = neq(_T_141, UInt<1>("h00")) @[PositDef.scala 196:59]
    valStickyVec[0] <= _T_143 @[PositDef.scala 196:21]
    node _T_144 = bits(io.in, 6, 0) @[PositDef.scala 197:32]
    node _T_145 = not(_T_144) @[PositDef.scala 197:62]
    node _T_147 = eq(_T_145, UInt<1>("h00")) @[PositDef.scala 197:62]
    valStickyAndVec[0] <= _T_147 @[PositDef.scala 197:24]
    node _T_148 = bits(io.shift, 0, 0) @[PositDef.scala 209:20]
    node _T_150 = bits(valVector[0], 0, 0) @[PositDef.scala 212:52]
    valVectorOfVecs[1][0] <= _T_150 @[PositDef.scala 212:33]
    node _T_151 = bits(io.shift, 0, 0) @[PositDef.scala 209:20]
    node _T_153 = bits(valVector[0], 1, 1) @[PositDef.scala 212:52]
    valVectorOfVecs[1][1] <= _T_153 @[PositDef.scala 212:33]
    node _T_154 = bits(io.shift, 0, 0) @[PositDef.scala 203:20]
    node _T_156 = bits(valVector[0], 2, 2) @[PositDef.scala 206:52]
    valVectorOfVecs[1][2] <= _T_156 @[PositDef.scala 206:33]
    wire _T_158 : UInt<1> @[PositDef.scala 216:28]
    wire _T_160 : UInt<1> @[PositDef.scala 217:31]
    node _T_161 = bits(io.shift, 0, 0) @[PositDef.scala 218:16]
    _T_158 <= UInt<1>("h00") @[PositDef.scala 223:20]
    _T_160 <= UInt<1>("h01") @[PositDef.scala 224:23]
    node _T_165 = or(valStickyVec[0], _T_158) @[PositDef.scala 226:44]
    valStickyVec[1] <= _T_165 @[PositDef.scala 226:21]
    node _T_166 = and(valStickyAndVec[0], _T_160) @[PositDef.scala 227:48]
    valStickyAndVec[1] <= _T_166 @[PositDef.scala 227:24]
    node _T_167 = bits(io.shift, 1, 1) @[PositDef.scala 209:20]
    node _T_169 = bits(valVector[1], 0, 0) @[PositDef.scala 212:52]
    valVectorOfVecs[2][0] <= _T_169 @[PositDef.scala 212:33]
    node _T_170 = bits(io.shift, 1, 1) @[PositDef.scala 203:20]
    node _T_172 = bits(valVector[1], 1, 1) @[PositDef.scala 206:52]
    valVectorOfVecs[2][1] <= _T_172 @[PositDef.scala 206:33]
    node _T_173 = bits(io.shift, 1, 1) @[PositDef.scala 203:20]
    node _T_175 = bits(valVector[1], 2, 2) @[PositDef.scala 206:52]
    valVectorOfVecs[2][2] <= _T_175 @[PositDef.scala 206:33]
    wire _T_177 : UInt<1> @[PositDef.scala 216:28]
    wire _T_179 : UInt<1> @[PositDef.scala 217:31]
    node _T_180 = bits(io.shift, 1, 1) @[PositDef.scala 218:16]
    _T_177 <= UInt<1>("h00") @[PositDef.scala 223:20]
    _T_179 <= UInt<1>("h01") @[PositDef.scala 224:23]
    node _T_184 = or(valStickyVec[1], _T_177) @[PositDef.scala 226:44]
    valStickyVec[2] <= _T_184 @[PositDef.scala 226:21]
    node _T_185 = and(valStickyAndVec[1], _T_179) @[PositDef.scala 227:48]
    valStickyAndVec[2] <= _T_185 @[PositDef.scala 227:24]
    node _T_187 = geq(io.shift, UInt<2>("h03")) @[PositDef.scala 249:27]
    maxShift <= _T_187 @[PositDef.scala 249:14]
    io.out <= valVector[2] @[PositDef.scala 255:14]
    node _T_189 = bits(valSticky, 2, 2) @[PositDef.scala 256:29]
    io.sticky <= _T_189 @[PositDef.scala 256:17]
    node _T_190 = bits(valStickyAnd, 2, 2) @[PositDef.scala 257:35]
    io.stickyAnd <= _T_190 @[PositDef.scala 257:20]
    
  module ZeroPadRight_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : UInt<4>, out : UInt<2>}
    
    node _T_9 = bits(io.in, 3, 1) @[PositDef.scala 139:20]
    io.out <= _T_9 @[PositDef.scala 139:12]
    
  module PositMultiply : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, flip b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, trailingBits : UInt<2>, stickyBit : UInt<1>}
    
    wire abSign : UInt<1> @[PositMultiply.scala 31:20]
    wire abExp : UInt<6> @[PositMultiply.scala 32:19]
    wire abExpTooSmall : UInt<1> @[PositMultiply.scala 33:27]
    wire abExpTooLarge : UInt<1> @[PositMultiply.scala 34:27]
    wire abExpShift : UInt<1> @[PositMultiply.scala 35:24]
    wire finalExpExtended : UInt<6> @[PositMultiply.scala 37:30]
    wire finalExp : UInt<5> @[PositMultiply.scala 38:22]
    wire abUnshiftedProduct : UInt<10> @[PositMultiply.scala 39:32]
    wire abShiftedProduct : UInt<10> @[PositMultiply.scala 40:30]
    wire underflowShift : UInt<4> @[PositMultiply.scala 41:28]
    wire underflowProduct : UInt<3> @[PositMultiply.scala 42:30]
    wire underflowSticky : UInt<1> @[PositMultiply.scala 44:29]
    wire normalTrailingBits : UInt<2> @[PositMultiply.scala 45:32]
    wire normalStickyBit : UInt<1> @[PositMultiply.scala 46:29]
    inst shiftRightWithSticky of ShiftRightSticky @[PositMultiply.scala 49:36]
    shiftRightWithSticky.clock <= clock
    shiftRightWithSticky.reset <= reset
    shiftRightWithSticky.io.in <= abShiftedProduct @[PositMultiply.scala 52:30]
    shiftRightWithSticky.io.shift <= underflowShift @[PositMultiply.scala 53:33]
    underflowProduct <= shiftRightWithSticky.io.out @[PositMultiply.scala 54:19]
    underflowSticky <= shiftRightWithSticky.io.sticky @[PositMultiply.scala 55:19]
    wire unusedStickyAnd : UInt<1> @[PositMultiply.scala 57:29]
    unusedStickyAnd <= shiftRightWithSticky.io.stickyAnd @[PositMultiply.scala 58:19]
    inst zeroPadRight of ZeroPadRight_1 @[PositMultiply.scala 64:28]
    zeroPadRight.clock <= clock
    zeroPadRight.reset <= reset
    node _T_30 = bits(abShiftedProduct, 3, 0) @[PositMultiply.scala 66:41]
    zeroPadRight.io.in <= _T_30 @[PositMultiply.scala 66:22]
    normalTrailingBits <= zeroPadRight.io.out @[PositMultiply.scala 67:24]
    node _T_31 = xor(io.a.sign, io.b.sign) @[PositMultiply.scala 70:23]
    abSign <= _T_31 @[PositMultiply.scala 70:10]
    node _T_33 = cat(UInt<1>("h01"), io.a.fraction) @[Cat.scala 30:58]
    node _T_35 = cat(UInt<1>("h01"), io.b.fraction) @[Cat.scala 30:58]
    node _T_36 = mul(_T_33, _T_35) @[PositMultiply.scala 74:54]
    abUnshiftedProduct <= _T_36 @[PositMultiply.scala 74:22]
    node _T_37 = bits(abUnshiftedProduct, 9, 9) @[PositMultiply.scala 78:35]
    abExpShift <= _T_37 @[PositMultiply.scala 78:14]
    node _T_38 = add(io.a.exponent, io.b.exponent) @[PositMultiply.scala 83:26]
    node _T_39 = tail(_T_38, 1) @[PositMultiply.scala 83:26]
    node _T_40 = add(_T_39, abExpShift) @[PositMultiply.scala 83:42]
    node _T_41 = tail(_T_40, 1) @[PositMultiply.scala 83:42]
    abExp <= _T_41 @[PositMultiply.scala 83:9]
    node _T_42 = bits(abExpShift, 0, 0) @[PositMultiply.scala 88:26]
    when _T_42 : @[PositMultiply.scala 88:30]
      abShiftedProduct <= abUnshiftedProduct @[PositMultiply.scala 89:22]
      skip @[PositMultiply.scala 88:30]
    else : @[PositMultiply.scala 90:16]
      node _T_43 = bits(abUnshiftedProduct, 8, 0) @[PositMultiply.scala 91:47]
      node _T_45 = cat(_T_43, UInt<1>("h00")) @[Cat.scala 30:58]
      abShiftedProduct <= _T_45 @[PositMultiply.scala 91:22]
      skip @[PositMultiply.scala 90:16]
    node _T_47 = lt(abExp, UInt<4>("h0c")) @[PositMultiply.scala 96:27]
    abExpTooSmall <= _T_47 @[PositMultiply.scala 96:17]
    node _T_49 = gt(abExp, UInt<6>("h024")) @[PositMultiply.scala 99:27]
    abExpTooLarge <= _T_49 @[PositMultiply.scala 99:17]
    node _T_51 = sub(abExp, UInt<4>("h0c")) @[PositMultiply.scala 101:29]
    node _T_52 = asUInt(_T_51) @[PositMultiply.scala 101:29]
    node _T_53 = tail(_T_52, 1) @[PositMultiply.scala 101:29]
    finalExpExtended <= _T_53 @[PositMultiply.scala 101:20]
    node _T_54 = bits(finalExpExtended, 4, 0) @[PositMultiply.scala 103:31]
    finalExp <= _T_54 @[PositMultiply.scala 103:12]
    node _T_56 = bits(abExp, 3, 0) @[PositMultiply.scala 108:50]
    node _T_57 = sub(UInt<4>("h0c"), _T_56) @[PositMultiply.scala 108:43]
    node _T_58 = asUInt(_T_57) @[PositMultiply.scala 108:43]
    node _T_59 = tail(_T_58, 1) @[PositMultiply.scala 108:43]
    underflowShift <= _T_59 @[PositMultiply.scala 108:18]
    node _T_60 = or(io.a.isInf, io.b.isInf) @[PositMultiply.scala 110:30]
    io.out.isInf <= _T_60 @[PositMultiply.scala 110:16]
    node _T_62 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 112:21]
    node _T_63 = or(io.a.isZero, io.b.isZero) @[PositMultiply.scala 112:52]
    node _T_64 = and(_T_62, _T_63) @[PositMultiply.scala 112:36]
    io.out.isZero <= _T_64 @[PositMultiply.scala 112:17]
    node _T_66 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 114:19]
    node _T_67 = bits(abSign, 0, 0) @[PositMultiply.scala 114:50]
    node _T_68 = and(_T_66, _T_67) @[PositMultiply.scala 114:34]
    io.out.sign <= _T_68 @[PositMultiply.scala 114:15]
    node _T_69 = or(io.out.isZero, io.out.isInf) @[PositMultiply.scala 116:22]
    when _T_69 : @[PositMultiply.scala 116:39]
      io.out.exponent <= UInt<1>("h00") @[PositMultiply.scala 117:21]
      skip @[PositMultiply.scala 116:39]
    else : @[PositMultiply.scala 118:39]
      node _T_71 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 118:35]
      when _T_71 : @[PositMultiply.scala 118:39]
        io.out.exponent <= UInt<5>("h018") @[PositMultiply.scala 119:21]
        skip @[PositMultiply.scala 118:39]
      else : @[PositMultiply.scala 120:16]
        io.out.exponent <= finalExp @[PositMultiply.scala 121:21]
        skip @[PositMultiply.scala 120:16]
    node _T_73 = or(io.out.isInf, io.out.isZero) @[PositMultiply.scala 124:21]
    node _T_74 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 124:61]
    node _T_75 = or(_T_73, _T_74) @[PositMultiply.scala 124:38]
    when _T_75 : @[PositMultiply.scala 124:65]
      io.out.fraction <= UInt<1>("h00") @[PositMultiply.scala 125:21]
      skip @[PositMultiply.scala 124:65]
    else : @[PositMultiply.scala 126:16]
      node _T_77 = bits(abShiftedProduct, 8, 4) @[PositMultiply.scala 127:40]
      io.out.fraction <= _T_77 @[PositMultiply.scala 127:21]
      skip @[PositMultiply.scala 126:16]
    node _T_78 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 130:21]
    node _T_79 = or(_T_78, io.b.isZero) @[PositMultiply.scala 130:36]
    node _T_80 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 130:74]
    node _T_81 = or(_T_79, _T_80) @[PositMultiply.scala 130:51]
    when _T_81 : @[PositMultiply.scala 130:78]
      io.trailingBits <= UInt<1>("h00") @[PositMultiply.scala 131:21]
      skip @[PositMultiply.scala 130:78]
    else : @[PositMultiply.scala 132:39]
      node _T_83 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 132:35]
      when _T_83 : @[PositMultiply.scala 132:39]
        node _T_84 = bits(underflowProduct, 1, 0) @[PositMultiply.scala 133:40]
        io.trailingBits <= _T_84 @[PositMultiply.scala 133:21]
        skip @[PositMultiply.scala 132:39]
      else : @[PositMultiply.scala 134:16]
        io.trailingBits <= normalTrailingBits @[PositMultiply.scala 135:21]
        skip @[PositMultiply.scala 134:16]
    node _T_85 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 138:21]
    node _T_86 = or(_T_85, io.b.isZero) @[PositMultiply.scala 138:36]
    node _T_87 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 138:74]
    node _T_88 = or(_T_86, _T_87) @[PositMultiply.scala 138:51]
    when _T_88 : @[PositMultiply.scala 138:78]
      io.stickyBit <= UInt<1>("h00") @[PositMultiply.scala 139:18]
      skip @[PositMultiply.scala 138:78]
    else : @[PositMultiply.scala 140:39]
      node _T_90 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 140:35]
      when _T_90 : @[PositMultiply.scala 140:39]
        io.stickyBit <= underflowSticky @[PositMultiply.scala 141:18]
        skip @[PositMultiply.scala 140:39]
      else : @[PositMultiply.scala 142:16]
        io.stickyBit <= normalStickyBit @[PositMultiply.scala 143:18]
        skip @[PositMultiply.scala 142:16]
    node _T_91 = bits(abShiftedProduct, 1, 0) @[PositMultiply.scala 147:40]
    node _T_93 = neq(_T_91, UInt<1>("h00")) @[PositMultiply.scala 147:101]
    normalStickyBit <= _T_93 @[PositMultiply.scala 147:21]
    
  module Test : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst gen of DataGen @[Test.scala 32:19]
    gen.clock <= clock
    gen.reset <= reset
    inst multiply of PositMultiply @[Test.scala 33:24]
    multiply.clock <= clock
    multiply.reset <= reset
    multiply.io.a.fraction <= gen.io.a.fraction @[Test.scala 34:17]
    multiply.io.a.exponent <= gen.io.a.exponent @[Test.scala 34:17]
    multiply.io.a.sign <= gen.io.a.sign @[Test.scala 34:17]
    multiply.io.a.isInf <= gen.io.a.isInf @[Test.scala 34:17]
    multiply.io.a.isZero <= gen.io.a.isZero @[Test.scala 34:17]
    multiply.io.b.fraction <= gen.io.b.fraction @[Test.scala 35:17]
    multiply.io.b.exponent <= gen.io.b.exponent @[Test.scala 35:17]
    multiply.io.b.sign <= gen.io.b.sign @[Test.scala 35:17]
    multiply.io.b.isInf <= gen.io.b.isInf @[Test.scala 35:17]
    multiply.io.b.isZero <= gen.io.b.isZero @[Test.scala 35:17]
    wire trailingBits : UInt<2> @[Test.scala 37:26]
    wire stickyBit : UInt<1> @[Test.scala 38:23]
    trailingBits <= multiply.io.trailingBits @[Test.scala 40:16]
    stickyBit <= multiply.io.stickyBit @[Test.scala 41:13]
    wire output : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[Test.scala 43:20]
    output.fraction <= multiply.io.out.fraction @[Test.scala 45:10]
    output.exponent <= multiply.io.out.exponent @[Test.scala 45:10]
    output.sign <= multiply.io.out.sign @[Test.scala 45:10]
    output.isInf <= multiply.io.out.isInf @[Test.scala 45:10]
    output.isZero <= multiply.io.out.isZero @[Test.scala 45:10]
    node _T_8 = bits(reset, 0, 0) @[Test.scala 48:11]
    node _T_10 = eq(_T_8, UInt<1>("h00")) @[Test.scala 48:11]
    when _T_10 : @[Test.scala 48:11]
      printf(clock, UInt<1>(1), "a.exponent is %b \n", gen.io.a.exponent) @[Test.scala 48:11]
      skip @[Test.scala 48:11]
    node _T_11 = bits(reset, 0, 0) @[Test.scala 49:11]
    node _T_13 = eq(_T_11, UInt<1>("h00")) @[Test.scala 49:11]
    when _T_13 : @[Test.scala 49:11]
      printf(clock, UInt<1>(1), "a.fraction is %b \n", gen.io.a.fraction) @[Test.scala 49:11]
      skip @[Test.scala 49:11]
    node _T_14 = bits(reset, 0, 0) @[Test.scala 50:11]
    node _T_16 = eq(_T_14, UInt<1>("h00")) @[Test.scala 50:11]
    when _T_16 : @[Test.scala 50:11]
      printf(clock, UInt<1>(1), "b.exponent is %b \n", gen.io.b.exponent) @[Test.scala 50:11]
      skip @[Test.scala 50:11]
    node _T_17 = bits(reset, 0, 0) @[Test.scala 51:11]
    node _T_19 = eq(_T_17, UInt<1>("h00")) @[Test.scala 51:11]
    when _T_19 : @[Test.scala 51:11]
      printf(clock, UInt<1>(1), "b.fraction is %b \n", gen.io.b.fraction) @[Test.scala 51:11]
      skip @[Test.scala 51:11]
    node _T_20 = bits(reset, 0, 0) @[Test.scala 53:11]
    node _T_22 = eq(_T_20, UInt<1>("h00")) @[Test.scala 53:11]
    when _T_22 : @[Test.scala 53:11]
      printf(clock, UInt<1>(1), "out.sign is %b \n", multiply.io.out.sign) @[Test.scala 53:11]
      skip @[Test.scala 53:11]
    node _T_23 = bits(reset, 0, 0) @[Test.scala 54:11]
    node _T_25 = eq(_T_23, UInt<1>("h00")) @[Test.scala 54:11]
    when _T_25 : @[Test.scala 54:11]
      printf(clock, UInt<1>(1), "out.isZero is %b \n", multiply.io.out.isZero) @[Test.scala 54:11]
      skip @[Test.scala 54:11]
    node _T_26 = bits(reset, 0, 0) @[Test.scala 55:11]
    node _T_28 = eq(_T_26, UInt<1>("h00")) @[Test.scala 55:11]
    when _T_28 : @[Test.scala 55:11]
      printf(clock, UInt<1>(1), "out.isInf is %b \n", multiply.io.out.isInf) @[Test.scala 55:11]
      skip @[Test.scala 55:11]
    node _T_29 = bits(reset, 0, 0) @[Test.scala 57:11]
    node _T_31 = eq(_T_29, UInt<1>("h00")) @[Test.scala 57:11]
    when _T_31 : @[Test.scala 57:11]
      printf(clock, UInt<1>(1), "out.trailingBits is %b \n", trailingBits) @[Test.scala 57:11]
      skip @[Test.scala 57:11]
    node _T_32 = bits(reset, 0, 0) @[Test.scala 58:11]
    node _T_34 = eq(_T_32, UInt<1>("h00")) @[Test.scala 58:11]
    when _T_34 : @[Test.scala 58:11]
      printf(clock, UInt<1>(1), "out.stickyBit is %b \n", stickyBit) @[Test.scala 58:11]
      skip @[Test.scala 58:11]
    node _T_35 = bits(reset, 0, 0) @[Test.scala 60:11]
    node _T_37 = eq(_T_35, UInt<1>("h00")) @[Test.scala 60:11]
    when _T_37 : @[Test.scala 60:11]
      printf(clock, UInt<1>(1), "out.exponent is %b \n", multiply.io.out.exponent) @[Test.scala 60:11]
      skip @[Test.scala 60:11]
    node _T_38 = bits(reset, 0, 0) @[Test.scala 61:11]
    node _T_40 = eq(_T_38, UInt<1>("h00")) @[Test.scala 61:11]
    when _T_40 : @[Test.scala 61:11]
      printf(clock, UInt<1>(1), "out.fraction is %b \n", multiply.io.out.fraction) @[Test.scala 61:11]
      skip @[Test.scala 61:11]
    
