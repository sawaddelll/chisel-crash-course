;buildInfoPackage: chisel3, version: 3.1.7, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-03-20 22:15:13.399, builtAtMillis: 1553120113399
circuit Test : 
  module DataGen : 
    input clock : Clock
    input reset : UInt<1>
    output io : {a : UInt<8>, b : UInt<8>, flip y : UInt<8>, flip prod : UInt<16>, flip ovfl : UInt<1>, flip zero : UInt<1>, flip neg : UInt<1>, flip ctrl : UInt<3>}
    
    reg value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 26:33]
    when UInt<1>("h01") : @[Counter.scala 63:17]
      node _T_25 = eq(value, UInt<2>("h03")) @[Counter.scala 34:24]
      node _T_27 = add(value, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_28 = tail(_T_27, 1) @[Counter.scala 35:22]
      value <= _T_28 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_29 = and(UInt<1>("h01"), _T_25) @[Counter.scala 64:20]
    wire slowclk : UInt<1> @[Test.scala 20:21]
    node _T_32 = rem(value, UInt<2>("h02")) @[Test.scala 21:14]
    node _T_34 = eq(_T_32, UInt<1>("h00")) @[Test.scala 21:19]
    when _T_34 : @[Test.scala 21:28]
      slowclk <= UInt<1>("h01") @[Test.scala 22:13]
      skip @[Test.scala 21:28]
    else : @[Test.scala 23:16]
      slowclk <= UInt<1>("h00") @[Test.scala 24:13]
      skip @[Test.scala 23:16]
    reg value_1 : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 26:33]
    when slowclk : @[Counter.scala 63:17]
      node _T_40 = eq(value_1, UInt<8>("h0ff")) @[Counter.scala 34:24]
      node _T_42 = add(value_1, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_43 = tail(_T_42, 1) @[Counter.scala 35:22]
      value_1 <= _T_43 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_44 = and(slowclk, _T_40) @[Counter.scala 64:20]
    wire countOn : UInt<1> @[Test.scala 27:21]
    reg value_2 : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 26:33]
    when countOn : @[Counter.scala 63:17]
      node _T_49 = eq(value_2, UInt<8>("h0ff")) @[Counter.scala 34:24]
      node _T_51 = add(value_2, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_52 = tail(_T_51, 1) @[Counter.scala 35:22]
      value_2 <= _T_52 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_53 = and(countOn, _T_49) @[Counter.scala 64:20]
    node _T_55 = gt(value_1, UInt<4>("h08")) @[Test.scala 29:12]
    when _T_55 : @[Test.scala 29:19]
      countOn <= UInt<1>("h01") @[Test.scala 30:13]
      io.b <= value_2 @[Test.scala 31:10]
      skip @[Test.scala 29:19]
    else : @[Test.scala 32:16]
      countOn <= UInt<1>("h00") @[Test.scala 33:13]
      io.b <= UInt<1>("h01") @[Test.scala 34:10]
      skip @[Test.scala 32:16]
    io.a <= value_1 @[Test.scala 37:8]
    reg aIn : UInt, clock with : (reset => (reset, UInt<1>("h00"))) @[Test.scala 39:20]
    aIn <= io.a @[Test.scala 39:20]
    reg bIn : UInt, clock with : (reset => (reset, UInt<1>("h00"))) @[Test.scala 40:20]
    bIn <= io.b @[Test.scala 40:20]
    reg prodIn : UInt, clock with : (reset => (reset, UInt<1>("h00"))) @[Test.scala 41:23]
    prodIn <= io.prod @[Test.scala 41:23]
    reg ovflIn : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Test.scala 42:23]
    ovflIn <= io.ovfl @[Test.scala 42:23]
    wire zeroIn : UInt<1> @[Test.scala 43:20]
    zeroIn <= io.zero @[Test.scala 44:10]
    wire negIn : UInt<1> @[Test.scala 45:19]
    negIn <= io.neg @[Test.scala 46:9]
    reg ctrlIn : UInt, clock with : (reset => (reset, UInt<1>("h00"))) @[Test.scala 47:23]
    ctrlIn <= io.ctrl @[Test.scala 47:23]
    when UInt<1>("h01") : @[Test.scala 50:16]
      node _T_72 = eq(ctrlIn, UInt<3>("h00")) @[Test.scala 52:18]
      when _T_72 : @[Test.scala 52:35]
        node _T_73 = bits(reset, 0, 0) @[Test.scala 53:15]
        node _T_75 = eq(_T_73, UInt<1>("h00")) @[Test.scala 53:15]
        when _T_75 : @[Test.scala 53:15]
          printf(clock, UInt<1>(1), "passThrough \n") @[Test.scala 53:15]
          skip @[Test.scala 53:15]
        skip @[Test.scala 52:35]
      else : @[Test.scala 54:34]
        node _T_76 = eq(ctrlIn, UInt<3>("h01")) @[Test.scala 54:25]
        when _T_76 : @[Test.scala 54:34]
          node _T_77 = bits(reset, 0, 0) @[Test.scala 55:15]
          node _T_79 = eq(_T_77, UInt<1>("h00")) @[Test.scala 55:15]
          when _T_79 : @[Test.scala 55:15]
            printf(clock, UInt<1>(1), "add \n") @[Test.scala 55:15]
            skip @[Test.scala 55:15]
          skip @[Test.scala 54:34]
        else : @[Test.scala 56:39]
          node _T_80 = eq(ctrlIn, UInt<3>("h02")) @[Test.scala 56:25]
          when _T_80 : @[Test.scala 56:39]
            node _T_81 = bits(reset, 0, 0) @[Test.scala 57:15]
            node _T_83 = eq(_T_81, UInt<1>("h00")) @[Test.scala 57:15]
            when _T_83 : @[Test.scala 57:15]
              printf(clock, UInt<1>(1), "subtract \n") @[Test.scala 57:15]
              skip @[Test.scala 57:15]
            skip @[Test.scala 56:39]
          else : @[Test.scala 58:39]
            node _T_84 = eq(ctrlIn, UInt<3>("h03")) @[Test.scala 58:25]
            when _T_84 : @[Test.scala 58:39]
              node _T_85 = bits(reset, 0, 0) @[Test.scala 59:15]
              node _T_87 = eq(_T_85, UInt<1>("h00")) @[Test.scala 59:15]
              when _T_87 : @[Test.scala 59:15]
                printf(clock, UInt<1>(1), "multiply \n") @[Test.scala 59:15]
                skip @[Test.scala 59:15]
              skip @[Test.scala 58:39]
            else : @[Test.scala 60:37]
              node _T_88 = eq(ctrlIn, UInt<3>("h04")) @[Test.scala 60:25]
              when _T_88 : @[Test.scala 60:37]
                node _T_89 = bits(reset, 0, 0) @[Test.scala 61:15]
                node _T_91 = eq(_T_89, UInt<1>("h00")) @[Test.scala 61:15]
                when _T_91 : @[Test.scala 61:15]
                  printf(clock, UInt<1>(1), "divide \n") @[Test.scala 61:15]
                  skip @[Test.scala 61:15]
                skip @[Test.scala 60:37]
              else : @[Test.scala 62:34]
                node _T_92 = eq(ctrlIn, UInt<3>("h05")) @[Test.scala 62:25]
                when _T_92 : @[Test.scala 62:34]
                  node _T_93 = bits(reset, 0, 0) @[Test.scala 63:15]
                  node _T_95 = eq(_T_93, UInt<1>("h00")) @[Test.scala 63:15]
                  when _T_95 : @[Test.scala 63:15]
                    printf(clock, UInt<1>(1), "and \n") @[Test.scala 63:15]
                    skip @[Test.scala 63:15]
                  node _T_96 = bits(reset, 0, 0) @[Test.scala 64:15]
                  node _T_98 = eq(_T_96, UInt<1>("h00")) @[Test.scala 64:15]
                  when _T_98 : @[Test.scala 64:15]
                    printf(clock, UInt<1>(1), "%b &\n%b = \n%b \n", aIn, bIn, io.y) @[Test.scala 64:15]
                    skip @[Test.scala 64:15]
                  skip @[Test.scala 62:34]
                else : @[Test.scala 65:33]
                  node _T_99 = eq(ctrlIn, UInt<3>("h06")) @[Test.scala 65:25]
                  when _T_99 : @[Test.scala 65:33]
                    node _T_100 = bits(reset, 0, 0) @[Test.scala 66:15]
                    node _T_102 = eq(_T_100, UInt<1>("h00")) @[Test.scala 66:15]
                    when _T_102 : @[Test.scala 66:15]
                      printf(clock, UInt<1>(1), "or \n") @[Test.scala 66:15]
                      skip @[Test.scala 66:15]
                    node _T_103 = bits(reset, 0, 0) @[Test.scala 67:15]
                    node _T_105 = eq(_T_103, UInt<1>("h00")) @[Test.scala 67:15]
                    when _T_105 : @[Test.scala 67:15]
                      printf(clock, UInt<1>(1), "%b |\n%b = \n%b \n", aIn, bIn, io.y) @[Test.scala 67:15]
                      skip @[Test.scala 67:15]
                    skip @[Test.scala 65:33]
                  else : @[Test.scala 68:34]
                    node _T_106 = eq(ctrlIn, UInt<3>("h07")) @[Test.scala 68:25]
                    when _T_106 : @[Test.scala 68:34]
                      node _T_107 = bits(reset, 0, 0) @[Test.scala 69:15]
                      node _T_109 = eq(_T_107, UInt<1>("h00")) @[Test.scala 69:15]
                      when _T_109 : @[Test.scala 69:15]
                        printf(clock, UInt<1>(1), "xor \n") @[Test.scala 69:15]
                        skip @[Test.scala 69:15]
                      node _T_110 = bits(reset, 0, 0) @[Test.scala 70:15]
                      node _T_112 = eq(_T_110, UInt<1>("h00")) @[Test.scala 70:15]
                      when _T_112 : @[Test.scala 70:15]
                        printf(clock, UInt<1>(1), "%b ^\n%b = \n%b \n", aIn, bIn, io.y) @[Test.scala 70:15]
                        skip @[Test.scala 70:15]
                      skip @[Test.scala 68:34]
                    else : @[Test.scala 71:19]
                      node _T_113 = bits(reset, 0, 0) @[Test.scala 72:15]
                      node _T_115 = eq(_T_113, UInt<1>("h00")) @[Test.scala 72:15]
                      when _T_115 : @[Test.scala 72:15]
                        printf(clock, UInt<1>(1), " \n") @[Test.scala 72:15]
                        skip @[Test.scala 72:15]
                      skip @[Test.scala 71:19]
      node _T_116 = bits(reset, 0, 0) @[Test.scala 76:11]
      node _T_118 = eq(_T_116, UInt<1>("h00")) @[Test.scala 76:11]
      when _T_118 : @[Test.scala 76:11]
        printf(clock, UInt<1>(1), "a:%d b:%d result:%d prod:%d \novfl:%d zero:%d neg:%d \n \n", aIn, bIn, io.y, prodIn, ovflIn, zeroIn, negIn) @[Test.scala 76:11]
        skip @[Test.scala 76:11]
      skip @[Test.scala 50:16]
    
  module ALU : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip a : UInt<8>, flip b : UInt<8>, flip ctrl : UInt<3>, result : UInt<8>, negative : UInt<1>, zero : UInt<1>, overflow : UInt<1>, product : UInt<16>}
    
    wire out : UInt<8> @[Adder.scala 18:17]
    node _T_22 = bits(io.result, 7, 7) @[Adder.scala 19:27]
    io.negative <= _T_22 @[Adder.scala 19:15]
    node _T_24 = neq(io.result, UInt<1>("h00")) @[Adder.scala 20:30]
    node _T_25 = not(_T_24) @[Adder.scala 20:18]
    io.zero <= _T_25 @[Adder.scala 20:15]
    node _T_26 = add(io.a, io.b) @[Adder.scala 21:23]
    node addition = tail(_T_26, 1) @[Adder.scala 21:23]
    reg storedValue : UInt, clock with : (reset => (reset, UInt<1>("h00"))) @[Adder.scala 22:29]
    storedValue <= out @[Adder.scala 22:29]
    storedValue <= out @[Adder.scala 23:15]
    io.product <= UInt<16>("h00") @[Adder.scala 25:14]
    node _T_30 = eq(io.ctrl, UInt<3>("h00")) @[Adder.scala 26:16]
    when _T_30 : @[Adder.scala 26:33]
      out <= io.a @[Adder.scala 27:9]
      skip @[Adder.scala 26:33]
    else : @[Adder.scala 28:32]
      node _T_31 = eq(io.ctrl, UInt<3>("h01")) @[Adder.scala 28:23]
      when _T_31 : @[Adder.scala 28:32]
        node _T_32 = add(io.a, io.b) @[Adder.scala 29:17]
        node _T_33 = tail(_T_32, 1) @[Adder.scala 29:17]
        out <= _T_33 @[Adder.scala 29:9]
        skip @[Adder.scala 28:32]
      else : @[Adder.scala 30:37]
        node _T_34 = eq(io.ctrl, UInt<3>("h02")) @[Adder.scala 30:23]
        when _T_34 : @[Adder.scala 30:37]
          node _T_35 = sub(io.a, io.b) @[Adder.scala 31:17]
          node _T_36 = asUInt(_T_35) @[Adder.scala 31:17]
          node _T_37 = tail(_T_36, 1) @[Adder.scala 31:17]
          out <= _T_37 @[Adder.scala 31:9]
          skip @[Adder.scala 30:37]
        else : @[Adder.scala 32:37]
          node _T_38 = eq(io.ctrl, UInt<3>("h03")) @[Adder.scala 32:23]
          when _T_38 : @[Adder.scala 32:37]
            node _T_39 = mul(io.a, io.b) @[Adder.scala 33:24]
            io.product <= _T_39 @[Adder.scala 33:16]
            out <= io.product @[Adder.scala 34:9]
            skip @[Adder.scala 32:37]
          else : @[Adder.scala 35:35]
            node _T_40 = eq(io.ctrl, UInt<3>("h04")) @[Adder.scala 35:23]
            when _T_40 : @[Adder.scala 35:35]
              node _T_41 = div(io.a, io.b) @[Adder.scala 36:17]
              out <= _T_41 @[Adder.scala 36:9]
              skip @[Adder.scala 35:35]
            else : @[Adder.scala 37:32]
              node _T_42 = eq(io.ctrl, UInt<3>("h05")) @[Adder.scala 37:23]
              when _T_42 : @[Adder.scala 37:32]
                node _T_43 = and(io.a, io.b) @[Adder.scala 38:17]
                out <= _T_43 @[Adder.scala 38:9]
                skip @[Adder.scala 37:32]
              else : @[Adder.scala 39:31]
                node _T_44 = eq(io.ctrl, UInt<3>("h06")) @[Adder.scala 39:23]
                when _T_44 : @[Adder.scala 39:31]
                  node _T_45 = or(io.a, io.b) @[Adder.scala 40:17]
                  out <= _T_45 @[Adder.scala 40:9]
                  skip @[Adder.scala 39:31]
                else : @[Adder.scala 41:32]
                  node _T_46 = eq(io.ctrl, UInt<3>("h07")) @[Adder.scala 41:23]
                  when _T_46 : @[Adder.scala 41:32]
                    node _T_47 = xor(io.a, io.b) @[Adder.scala 42:17]
                    out <= _T_47 @[Adder.scala 42:9]
                    skip @[Adder.scala 41:32]
                  else : @[Adder.scala 43:16]
                    out <= UInt<8>("h00") @[Adder.scala 44:9]
                    skip @[Adder.scala 43:16]
    io.result <= storedValue @[Adder.scala 47:13]
    node _T_49 = bits(io.a, 7, 7) @[Adder.scala 48:23]
    node _T_50 = bits(io.b, 7, 7) @[Adder.scala 48:44]
    node _T_51 = eq(_T_49, _T_50) @[Adder.scala 48:36]
    node _T_52 = bits(out, 7, 7) @[Adder.scala 48:65]
    node _T_53 = bits(io.a, 7, 7) @[Adder.scala 48:86]
    node _T_54 = neq(_T_52, _T_53) @[Adder.scala 48:78]
    node _T_55 = and(_T_51, _T_54) @[Adder.scala 48:58]
    io.overflow <= _T_55 @[Adder.scala 48:15]
    
  module Test : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst gen of DataGen @[Test.scala 82:19]
    gen.clock <= clock
    gen.reset <= reset
    inst alu of ALU @[Test.scala 83:19]
    alu.clock <= clock
    alu.reset <= reset
    alu.io.a <= gen.io.a @[Test.scala 84:12]
    alu.io.b <= gen.io.b @[Test.scala 85:12]
    gen.io.y <= alu.io.result @[Test.scala 86:12]
    gen.io.prod <= alu.io.product @[Test.scala 87:15]
    gen.io.ovfl <= alu.io.overflow @[Test.scala 88:15]
    gen.io.zero <= alu.io.zero @[Test.scala 89:15]
    gen.io.neg <= alu.io.negative @[Test.scala 90:14]
    reg value : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Counter.scala 26:33]
    when UInt<1>("h01") : @[Counter.scala 63:17]
      node _T_9 = eq(value, UInt<3>("h07")) @[Counter.scala 34:24]
      node _T_11 = add(value, UInt<1>("h01")) @[Counter.scala 35:22]
      node _T_12 = tail(_T_11, 1) @[Counter.scala 35:22]
      value <= _T_12 @[Counter.scala 35:13]
      skip @[Counter.scala 63:17]
    node _T_13 = and(UInt<1>("h01"), _T_9) @[Counter.scala 64:20]
    alu.io.ctrl <= value @[Test.scala 92:15]
    gen.io.ctrl <= value @[Test.scala 93:15]
    
