;buildInfoPackage: chisel3, version: 3.1.8, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-07-08 17:44:42.884, builtAtMillis: 1562607882884
circuit Test : 
  module DataGen : 
    input clock : Clock
    input reset : UInt<1>
    output io : {a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}}
    
    io.a.isZero <= UInt<1>("h00") @[Test.scala 15:16]
    io.a.isInf <= UInt<1>("h00") @[Test.scala 16:16]
    io.a.sign <= UInt<1>("h01") @[Test.scala 17:16]
    io.b.sign <= UInt<1>("h01") @[Test.scala 19:14]
    io.b.isInf <= UInt<1>("h00") @[Test.scala 20:16]
    io.b.isZero <= UInt<1>("h00") @[Test.scala 21:16]
    io.a.exponent <= UInt<5>("h05") @[Test.scala 23:17]
    io.a.fraction <= UInt<4>("h00") @[Test.scala 24:17]
    io.b.exponent <= UInt<5>("h0a") @[Test.scala 26:17]
    io.b.fraction <= UInt<4>("h05") @[Test.scala 27:17]
    
  module PositMultiply : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip a : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, flip b : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, out : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>}, trailingBits : UInt<2>, stickyBit : UInt<1>}
    
    wire abSign : UInt<1> @[PositMultiply.scala 36:20]
    wire abExp : UInt<6> @[PositMultiply.scala 37:19]
    wire abExpTooSmall : UInt<1> @[PositMultiply.scala 38:27]
    wire abExpTooLarge : UInt<1> @[PositMultiply.scala 39:27]
    wire abExpShift : UInt<1> @[PositMultiply.scala 40:24]
    wire finalExpExtended : UInt<6> @[PositMultiply.scala 42:30]
    wire finalExp : UInt<5> @[PositMultiply.scala 43:22]
    wire abUnshiftedProduct : UInt<10> @[PositMultiply.scala 44:32]
    wire abShiftedProduct : UInt<10> @[PositMultiply.scala 45:30]
    wire underflowShift : UInt<4> @[PositMultiply.scala 46:28]
    wire underflowProduct : UInt<3> @[PositMultiply.scala 47:30]
    wire underflowSticky : UInt<1> @[PositMultiply.scala 49:29]
    wire normalTrailingBits : UInt<2> @[PositMultiply.scala 50:32]
    wire normalStickyBit : UInt<1> @[PositMultiply.scala 51:29]
    underflowProduct <= UInt<1>("h00") @[PositMultiply.scala 54:20]
    underflowSticky <= UInt<1>("h01") @[PositMultiply.scala 55:20]
    normalTrailingBits <= UInt<1>("h00") @[PositMultiply.scala 58:22]
    node _T_32 = xor(io.a.sign, io.b.sign) @[PositMultiply.scala 60:23]
    abSign <= _T_32 @[PositMultiply.scala 60:10]
    node _T_34 = cat(UInt<1>("h01"), io.a.fraction) @[Cat.scala 30:58]
    node _T_36 = cat(UInt<1>("h01"), io.b.fraction) @[Cat.scala 30:58]
    node _T_37 = mul(_T_34, _T_36) @[PositMultiply.scala 62:54]
    abUnshiftedProduct <= _T_37 @[PositMultiply.scala 62:22]
    node _T_38 = bits(abUnshiftedProduct, 9, 9) @[PositMultiply.scala 64:35]
    abExpShift <= _T_38 @[PositMultiply.scala 64:14]
    node _T_39 = add(io.a.exponent, io.b.exponent) @[PositMultiply.scala 66:26]
    node _T_40 = tail(_T_39, 1) @[PositMultiply.scala 66:26]
    node _T_41 = add(_T_40, abExpShift) @[PositMultiply.scala 66:42]
    node _T_42 = tail(_T_41, 1) @[PositMultiply.scala 66:42]
    abExp <= _T_42 @[PositMultiply.scala 66:9]
    node _T_43 = bits(abExpShift, 0, 0) @[PositMultiply.scala 68:26]
    when _T_43 : @[PositMultiply.scala 68:30]
      abShiftedProduct <= abUnshiftedProduct @[PositMultiply.scala 69:22]
      skip @[PositMultiply.scala 68:30]
    else : @[PositMultiply.scala 70:16]
      node _T_44 = bits(abUnshiftedProduct, 8, 0) @[PositMultiply.scala 71:47]
      node _T_46 = cat(_T_44, UInt<1>("h00")) @[Cat.scala 30:58]
      abShiftedProduct <= _T_46 @[PositMultiply.scala 71:22]
      skip @[PositMultiply.scala 70:16]
    node _T_48 = lt(abExp, UInt<4>("h0c")) @[PositMultiply.scala 75:27]
    abExpTooSmall <= _T_48 @[PositMultiply.scala 75:17]
    node _T_50 = gt(abExp, UInt<6>("h024")) @[PositMultiply.scala 77:27]
    abExpTooLarge <= _T_50 @[PositMultiply.scala 77:17]
    node _T_52 = sub(abExp, UInt<4>("h0c")) @[PositMultiply.scala 79:29]
    node _T_53 = asUInt(_T_52) @[PositMultiply.scala 79:29]
    node _T_54 = tail(_T_53, 1) @[PositMultiply.scala 79:29]
    finalExpExtended <= _T_54 @[PositMultiply.scala 79:20]
    node _T_55 = bits(finalExpExtended, 4, 0) @[PositMultiply.scala 81:31]
    finalExp <= _T_55 @[PositMultiply.scala 81:12]
    node _T_57 = bits(abExp, 3, 0) @[PositMultiply.scala 83:50]
    node _T_58 = sub(UInt<4>("h0c"), _T_57) @[PositMultiply.scala 83:43]
    node _T_59 = asUInt(_T_58) @[PositMultiply.scala 83:43]
    node _T_60 = tail(_T_59, 1) @[PositMultiply.scala 83:43]
    underflowShift <= _T_60 @[PositMultiply.scala 83:18]
    node _T_61 = or(io.a.isInf, io.b.isInf) @[PositMultiply.scala 85:30]
    io.out.isInf <= _T_61 @[PositMultiply.scala 85:16]
    node _T_63 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 87:21]
    node _T_64 = or(io.a.isZero, io.b.isZero) @[PositMultiply.scala 87:52]
    node _T_65 = and(_T_63, _T_64) @[PositMultiply.scala 87:36]
    io.out.isZero <= _T_65 @[PositMultiply.scala 87:17]
    node _T_67 = eq(io.out.isInf, UInt<1>("h00")) @[PositMultiply.scala 89:19]
    node _T_68 = bits(abSign, 0, 0) @[PositMultiply.scala 89:50]
    node _T_69 = and(_T_67, _T_68) @[PositMultiply.scala 89:34]
    io.out.sign <= _T_69 @[PositMultiply.scala 89:15]
    node _T_70 = or(io.out.isZero, io.out.isInf) @[PositMultiply.scala 91:22]
    when _T_70 : @[PositMultiply.scala 91:39]
      io.out.exponent <= UInt<1>("h00") @[PositMultiply.scala 92:21]
      skip @[PositMultiply.scala 91:39]
    else : @[PositMultiply.scala 93:39]
      node _T_72 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 93:35]
      when _T_72 : @[PositMultiply.scala 93:39]
        io.out.exponent <= UInt<5>("h018") @[PositMultiply.scala 94:21]
        skip @[PositMultiply.scala 93:39]
      else : @[PositMultiply.scala 95:16]
        io.out.exponent <= finalExp @[PositMultiply.scala 96:21]
        skip @[PositMultiply.scala 95:16]
    node _T_74 = or(io.out.isInf, io.out.isZero) @[PositMultiply.scala 99:21]
    node _T_75 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 99:61]
    node _T_76 = or(_T_74, _T_75) @[PositMultiply.scala 99:38]
    when _T_76 : @[PositMultiply.scala 99:65]
      io.out.fraction <= UInt<1>("h00") @[PositMultiply.scala 100:21]
      skip @[PositMultiply.scala 99:65]
    else : @[PositMultiply.scala 101:16]
      node _T_78 = bits(abShiftedProduct, 8, 4) @[PositMultiply.scala 102:40]
      io.out.fraction <= _T_78 @[PositMultiply.scala 102:21]
      skip @[PositMultiply.scala 101:16]
    node _T_79 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 105:21]
    node _T_80 = or(_T_79, io.b.isZero) @[PositMultiply.scala 105:36]
    node _T_81 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 105:74]
    node _T_82 = or(_T_80, _T_81) @[PositMultiply.scala 105:51]
    when _T_82 : @[PositMultiply.scala 105:78]
      io.trailingBits <= UInt<1>("h00") @[PositMultiply.scala 106:21]
      skip @[PositMultiply.scala 105:78]
    else : @[PositMultiply.scala 107:39]
      node _T_84 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 107:35]
      when _T_84 : @[PositMultiply.scala 107:39]
        node _T_85 = bits(underflowProduct, 1, 0) @[PositMultiply.scala 108:40]
        io.trailingBits <= _T_85 @[PositMultiply.scala 108:21]
        skip @[PositMultiply.scala 107:39]
      else : @[PositMultiply.scala 109:16]
        io.trailingBits <= normalTrailingBits @[PositMultiply.scala 110:21]
        skip @[PositMultiply.scala 109:16]
    node _T_86 = or(io.out.isInf, io.a.isZero) @[PositMultiply.scala 113:21]
    node _T_87 = or(_T_86, io.b.isZero) @[PositMultiply.scala 113:36]
    node _T_88 = bits(abExpTooLarge, 0, 0) @[PositMultiply.scala 113:74]
    node _T_89 = or(_T_87, _T_88) @[PositMultiply.scala 113:51]
    when _T_89 : @[PositMultiply.scala 113:78]
      io.stickyBit <= UInt<1>("h00") @[PositMultiply.scala 114:18]
      skip @[PositMultiply.scala 113:78]
    else : @[PositMultiply.scala 115:39]
      node _T_91 = bits(abExpTooSmall, 0, 0) @[PositMultiply.scala 115:35]
      when _T_91 : @[PositMultiply.scala 115:39]
        io.stickyBit <= underflowSticky @[PositMultiply.scala 116:18]
        skip @[PositMultiply.scala 115:39]
      else : @[PositMultiply.scala 117:16]
        io.stickyBit <= normalStickyBit @[PositMultiply.scala 118:18]
        skip @[PositMultiply.scala 117:16]
    node _T_92 = bits(abShiftedProduct, 1, 0) @[PositMultiply.scala 122:40]
    node _T_94 = neq(_T_92, UInt<1>("h00")) @[PositMultiply.scala 122:101]
    normalStickyBit <= _T_94 @[PositMultiply.scala 122:21]
    
  module Test : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst gen of DataGen @[Test.scala 32:19]
    gen.clock <= clock
    gen.reset <= reset
    inst multiply of PositMultiply @[Test.scala 33:24]
    multiply.clock <= clock
    multiply.reset <= reset
    multiply.io.a.fraction <= gen.io.a.fraction @[Test.scala 34:17]
    multiply.io.a.exponent <= gen.io.a.exponent @[Test.scala 34:17]
    multiply.io.a.sign <= gen.io.a.sign @[Test.scala 34:17]
    multiply.io.a.isInf <= gen.io.a.isInf @[Test.scala 34:17]
    multiply.io.a.isZero <= gen.io.a.isZero @[Test.scala 34:17]
    multiply.io.b.fraction <= gen.io.b.fraction @[Test.scala 35:17]
    multiply.io.b.exponent <= gen.io.b.exponent @[Test.scala 35:17]
    multiply.io.b.sign <= gen.io.b.sign @[Test.scala 35:17]
    multiply.io.b.isInf <= gen.io.b.isInf @[Test.scala 35:17]
    multiply.io.b.isZero <= gen.io.b.isZero @[Test.scala 35:17]
    wire trailingBits : UInt<2> @[Test.scala 37:26]
    wire stickyBit : UInt<1> @[Test.scala 38:23]
    trailingBits <= multiply.io.trailingBits @[Test.scala 40:16]
    stickyBit <= multiply.io.stickyBit @[Test.scala 41:13]
    wire output : {isZero : UInt<1>, isInf : UInt<1>, sign : UInt<1>, exponent : UInt<5>, fraction : UInt<4>} @[Test.scala 43:20]
    output.fraction <= multiply.io.out.fraction @[Test.scala 45:10]
    output.exponent <= multiply.io.out.exponent @[Test.scala 45:10]
    output.sign <= multiply.io.out.sign @[Test.scala 45:10]
    output.isInf <= multiply.io.out.isInf @[Test.scala 45:10]
    output.isZero <= multiply.io.out.isZero @[Test.scala 45:10]
    node _T_8 = bits(reset, 0, 0) @[Test.scala 48:11]
    node _T_10 = eq(_T_8, UInt<1>("h00")) @[Test.scala 48:11]
    when _T_10 : @[Test.scala 48:11]
      printf(clock, UInt<1>(1), "a.exponent is %b \n", gen.io.a.exponent) @[Test.scala 48:11]
      skip @[Test.scala 48:11]
    node _T_11 = bits(reset, 0, 0) @[Test.scala 49:11]
    node _T_13 = eq(_T_11, UInt<1>("h00")) @[Test.scala 49:11]
    when _T_13 : @[Test.scala 49:11]
      printf(clock, UInt<1>(1), "a.fraction is %b \n", gen.io.a.fraction) @[Test.scala 49:11]
      skip @[Test.scala 49:11]
    node _T_14 = bits(reset, 0, 0) @[Test.scala 50:11]
    node _T_16 = eq(_T_14, UInt<1>("h00")) @[Test.scala 50:11]
    when _T_16 : @[Test.scala 50:11]
      printf(clock, UInt<1>(1), "b.exponent is %b \n", gen.io.b.exponent) @[Test.scala 50:11]
      skip @[Test.scala 50:11]
    node _T_17 = bits(reset, 0, 0) @[Test.scala 51:11]
    node _T_19 = eq(_T_17, UInt<1>("h00")) @[Test.scala 51:11]
    when _T_19 : @[Test.scala 51:11]
      printf(clock, UInt<1>(1), "b.fraction is %b \n", gen.io.b.fraction) @[Test.scala 51:11]
      skip @[Test.scala 51:11]
    node _T_20 = bits(reset, 0, 0) @[Test.scala 53:11]
    node _T_22 = eq(_T_20, UInt<1>("h00")) @[Test.scala 53:11]
    when _T_22 : @[Test.scala 53:11]
      printf(clock, UInt<1>(1), "out.sign is %b \n", multiply.io.out.sign) @[Test.scala 53:11]
      skip @[Test.scala 53:11]
    node _T_23 = bits(reset, 0, 0) @[Test.scala 54:11]
    node _T_25 = eq(_T_23, UInt<1>("h00")) @[Test.scala 54:11]
    when _T_25 : @[Test.scala 54:11]
      printf(clock, UInt<1>(1), "out.isZero is %b \n", multiply.io.out.isZero) @[Test.scala 54:11]
      skip @[Test.scala 54:11]
    node _T_26 = bits(reset, 0, 0) @[Test.scala 55:11]
    node _T_28 = eq(_T_26, UInt<1>("h00")) @[Test.scala 55:11]
    when _T_28 : @[Test.scala 55:11]
      printf(clock, UInt<1>(1), "out.isInf is %b \n", multiply.io.out.isInf) @[Test.scala 55:11]
      skip @[Test.scala 55:11]
    node _T_29 = bits(reset, 0, 0) @[Test.scala 57:11]
    node _T_31 = eq(_T_29, UInt<1>("h00")) @[Test.scala 57:11]
    when _T_31 : @[Test.scala 57:11]
      printf(clock, UInt<1>(1), "out.trailingBits is %b \n", trailingBits) @[Test.scala 57:11]
      skip @[Test.scala 57:11]
    node _T_32 = bits(reset, 0, 0) @[Test.scala 58:11]
    node _T_34 = eq(_T_32, UInt<1>("h00")) @[Test.scala 58:11]
    when _T_34 : @[Test.scala 58:11]
      printf(clock, UInt<1>(1), "out.stickyBit is %b \n", stickyBit) @[Test.scala 58:11]
      skip @[Test.scala 58:11]
    node _T_35 = bits(reset, 0, 0) @[Test.scala 60:11]
    node _T_37 = eq(_T_35, UInt<1>("h00")) @[Test.scala 60:11]
    when _T_37 : @[Test.scala 60:11]
      printf(clock, UInt<1>(1), "out.exponent is %b \n", multiply.io.out.exponent) @[Test.scala 60:11]
      skip @[Test.scala 60:11]
    node _T_38 = bits(reset, 0, 0) @[Test.scala 61:11]
    node _T_40 = eq(_T_38, UInt<1>("h00")) @[Test.scala 61:11]
    when _T_40 : @[Test.scala 61:11]
      printf(clock, UInt<1>(1), "out.fraction is %b \n", multiply.io.out.fraction) @[Test.scala 61:11]
      skip @[Test.scala 61:11]
    
